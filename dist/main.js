/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/liquidjs/dist/liquid.browser.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/liquidjs/dist/liquid.browser.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AssertionError\": () => (/* binding */ AssertionError),\n/* harmony export */   \"Context\": () => (/* binding */ Context),\n/* harmony export */   \"Drop\": () => (/* binding */ Drop),\n/* harmony export */   \"Expression\": () => (/* binding */ Expression),\n/* harmony export */   \"Hash\": () => (/* binding */ Hash),\n/* harmony export */   \"InternalUndefinedVariableError\": () => (/* binding */ InternalUndefinedVariableError),\n/* harmony export */   \"Liquid\": () => (/* binding */ Liquid),\n/* harmony export */   \"LiquidError\": () => (/* binding */ LiquidError),\n/* harmony export */   \"ParseError\": () => (/* binding */ ParseError),\n/* harmony export */   \"ParseStream\": () => (/* binding */ ParseStream),\n/* harmony export */   \"RenderError\": () => (/* binding */ RenderError),\n/* harmony export */   \"TagToken\": () => (/* binding */ TagToken),\n/* harmony export */   \"TimezoneDate\": () => (/* binding */ TimezoneDate),\n/* harmony export */   \"Token\": () => (/* binding */ Token),\n/* harmony export */   \"TokenKind\": () => (/* binding */ TokenKind),\n/* harmony export */   \"TokenizationError\": () => (/* binding */ TokenizationError),\n/* harmony export */   \"Tokenizer\": () => (/* binding */ Tokenizer),\n/* harmony export */   \"TypeGuards\": () => (/* binding */ typeGuards),\n/* harmony export */   \"UndefinedVariableError\": () => (/* binding */ UndefinedVariableError),\n/* harmony export */   \"Value\": () => (/* binding */ Value),\n/* harmony export */   \"assert\": () => (/* binding */ assert),\n/* harmony export */   \"createTrie\": () => (/* binding */ createTrie),\n/* harmony export */   \"defaultOperators\": () => (/* binding */ defaultOperators),\n/* harmony export */   \"evalQuotedToken\": () => (/* binding */ evalQuotedToken),\n/* harmony export */   \"evalToken\": () => (/* binding */ evalToken),\n/* harmony export */   \"filters\": () => (/* binding */ builtinFilters),\n/* harmony export */   \"isFalsy\": () => (/* binding */ isFalsy),\n/* harmony export */   \"isTruthy\": () => (/* binding */ isTruthy),\n/* harmony export */   \"tags\": () => (/* binding */ index),\n/* harmony export */   \"toPromise\": () => (/* binding */ toPromise),\n/* harmony export */   \"toThenable\": () => (/* binding */ toThenable),\n/* harmony export */   \"toValue\": () => (/* binding */ toValue$1),\n/* harmony export */   \"version\": () => (/* binding */ version)\n/* harmony export */ });\n/*\n * liquidjs@9.36.0, https://github.com/harttle/liquidjs\n * (c) 2016-2022 harttle\n * Released under the MIT License.\n */\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\nvar Drop = /** @class */ (function () {\r\n    function Drop() {\r\n    }\r\n    Drop.prototype.valueOf = function () {\r\n        return undefined;\r\n    };\r\n    Drop.prototype.liquidMethodMissing = function (key) {\r\n        return undefined;\r\n    };\r\n    return Drop;\r\n}());\n\nvar toStr = Object.prototype.toString;\r\nvar toLowerCase = String.prototype.toLowerCase;\r\nvar hasOwnProperty = Object.hasOwnProperty;\r\nfunction isString(value) {\r\n    return typeof value === 'string';\r\n}\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nfunction isFunction(value) {\r\n    return typeof value === 'function';\r\n}\r\nfunction escapeRegex(str) {\r\n    return str.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\r\n}\r\nfunction stringify(value) {\r\n    value = toValue$1(value);\r\n    if (isString(value))\r\n        return value;\r\n    if (isNil(value))\r\n        return '';\r\n    if (isArray(value))\r\n        return value.map(function (x) { return stringify(x); }).join('');\r\n    return String(value);\r\n}\r\nfunction toValue$1(value) {\r\n    return value instanceof Drop ? value.valueOf() : value;\r\n}\r\nfunction isNumber(value) {\r\n    return typeof value === 'number';\r\n}\r\nfunction toLiquid(value) {\r\n    if (value && isFunction(value.toLiquid))\r\n        return toLiquid(value.toLiquid());\r\n    return value;\r\n}\r\nfunction isNil(value) {\r\n    return value == null;\r\n}\r\nfunction isArray(value) {\r\n    // be compatible with IE 8\r\n    return toStr.call(value) === '[object Array]';\r\n}\r\n/*\r\n * Iterates over own enumerable string keyed properties of an object and invokes iteratee for each property.\r\n * The iteratee is invoked with three arguments: (value, key, object).\r\n * Iteratee functions may exit iteration early by explicitly returning false.\r\n * @param {Object} object The object to iterate over.\r\n * @param {Function} iteratee The function invoked per iteration.\r\n * @return {Object} Returns object.\r\n */\r\nfunction forOwn(obj, iteratee) {\r\n    obj = obj || {};\r\n    for (var k in obj) {\r\n        if (hasOwnProperty.call(obj, k)) {\r\n            if (iteratee(obj[k], k, obj) === false)\r\n                break;\r\n        }\r\n    }\r\n    return obj;\r\n}\r\nfunction last$1(arr) {\r\n    return arr[arr.length - 1];\r\n}\r\n/*\r\n * Checks if value is the language type of Object.\r\n * (e.g. arrays, functions, objects, regexes, new Number(0), and new String(''))\r\n * @param {any} value The value to check.\r\n * @return {Boolean} Returns true if value is an object, else false.\r\n */\r\nfunction isObject(value) {\r\n    var type = typeof value;\r\n    return value !== null && (type === 'object' || type === 'function');\r\n}\r\nfunction range(start, stop, step) {\r\n    if (step === void 0) { step = 1; }\r\n    var arr = [];\r\n    for (var i = start; i < stop; i += step) {\r\n        arr.push(i);\r\n    }\r\n    return arr;\r\n}\r\nfunction padStart(str, length, ch) {\r\n    if (ch === void 0) { ch = ' '; }\r\n    return pad(str, length, ch, function (str, ch) { return ch + str; });\r\n}\r\nfunction padEnd(str, length, ch) {\r\n    if (ch === void 0) { ch = ' '; }\r\n    return pad(str, length, ch, function (str, ch) { return str + ch; });\r\n}\r\nfunction pad(str, length, ch, add) {\r\n    str = String(str);\r\n    var n = length - str.length;\r\n    while (n-- > 0)\r\n        str = add(str, ch);\r\n    return str;\r\n}\r\nfunction identify(val) {\r\n    return val;\r\n}\r\nfunction snakeCase(str) {\r\n    return str.replace(/(\\w?)([A-Z])/g, function (_, a, b) { return (a ? a + '_' : '') + b.toLowerCase(); });\r\n}\r\nfunction changeCase(str) {\r\n    var hasLowerCase = __spreadArray([], __read(str), false).some(function (ch) { return ch >= 'a' && ch <= 'z'; });\r\n    return hasLowerCase ? str.toUpperCase() : str.toLowerCase();\r\n}\r\nfunction ellipsis(str, N) {\r\n    return str.length > N ? str.substr(0, N - 3) + '...' : str;\r\n}\r\n// compare string in case-insensitive way, undefined values to the tail\r\nfunction caseInsensitiveCompare(a, b) {\r\n    if (a == null && b == null)\r\n        return 0;\r\n    if (a == null)\r\n        return 1;\r\n    if (b == null)\r\n        return -1;\r\n    a = toLowerCase.call(a);\r\n    b = toLowerCase.call(b);\r\n    if (a < b)\r\n        return -1;\r\n    if (a > b)\r\n        return 1;\r\n    return 0;\r\n}\r\nfunction argumentsToValue(fn) {\r\n    return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        return fn.apply(void 0, __spreadArray([], __read(args.map(toValue$1)), false));\r\n    };\r\n}\r\nfunction escapeRegExp(text) {\r\n    return text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\r\n}\n\nvar Node = /** @class */ (function () {\r\n    function Node(key, value, next, prev) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.next = next;\r\n        this.prev = prev;\r\n    }\r\n    return Node;\r\n}());\r\nvar LRU = /** @class */ (function () {\r\n    function LRU(limit, size) {\r\n        if (size === void 0) { size = 0; }\r\n        this.limit = limit;\r\n        this.size = size;\r\n        this.cache = {};\r\n        this.head = new Node('HEAD', null, null, null);\r\n        this.tail = new Node('TAIL', null, null, null);\r\n        this.head.next = this.tail;\r\n        this.tail.prev = this.head;\r\n    }\r\n    LRU.prototype.write = function (key, value) {\r\n        if (this.cache[key]) {\r\n            this.cache[key].value = value;\r\n        }\r\n        else {\r\n            var node = new Node(key, value, this.head.next, this.head);\r\n            this.head.next.prev = node;\r\n            this.head.next = node;\r\n            this.cache[key] = node;\r\n            this.size++;\r\n            this.ensureLimit();\r\n        }\r\n    };\r\n    LRU.prototype.read = function (key) {\r\n        if (!this.cache[key])\r\n            return;\r\n        var value = this.cache[key].value;\r\n        this.remove(key);\r\n        this.write(key, value);\r\n        return value;\r\n    };\r\n    LRU.prototype.remove = function (key) {\r\n        var node = this.cache[key];\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n        delete this.cache[key];\r\n        this.size--;\r\n    };\r\n    LRU.prototype.clear = function () {\r\n        this.head.next = this.tail;\r\n        this.tail.prev = this.head;\r\n        this.size = 0;\r\n        this.cache = {};\r\n    };\r\n    LRU.prototype.ensureLimit = function () {\r\n        if (this.size > this.limit)\r\n            this.remove(this.tail.prev.key);\r\n    };\r\n    return LRU;\r\n}());\n\nfunction domResolve(root, path) {\r\n    var base = document.createElement('base');\r\n    base.href = root;\r\n    var head = document.getElementsByTagName('head')[0];\r\n    head.insertBefore(base, head.firstChild);\r\n    var a = document.createElement('a');\r\n    a.href = path;\r\n    var resolved = a.href;\r\n    head.removeChild(base);\r\n    return resolved;\r\n}\r\nfunction resolve(root, filepath, ext) {\r\n    if (root.length && last$1(root) !== '/')\r\n        root += '/';\r\n    var url = domResolve(root, filepath);\r\n    return url.replace(/^(\\w+:\\/\\/[^/]+)(\\/[^?]+)/, function (str, origin, path) {\r\n        var last = path.split('/').pop();\r\n        if (/\\.\\w+$/.test(last))\r\n            return str;\r\n        return origin + path + ext;\r\n    });\r\n}\r\nfunction readFile(url) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            return [2 /*return*/, new Promise(function (resolve, reject) {\r\n                    var xhr = new XMLHttpRequest();\r\n                    xhr.onload = function () {\r\n                        if (xhr.status >= 200 && xhr.status < 300) {\r\n                            resolve(xhr.responseText);\r\n                        }\r\n                        else {\r\n                            reject(new Error(xhr.statusText));\r\n                        }\r\n                    };\r\n                    xhr.onerror = function () {\r\n                        reject(new Error('An error occurred whilst receiving the response.'));\r\n                    };\r\n                    xhr.open('GET', url);\r\n                    xhr.send();\r\n                })];\r\n        });\r\n    });\r\n}\r\nfunction readFileSync(url) {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open('GET', url, false);\r\n    xhr.send();\r\n    if (xhr.status < 200 || xhr.status >= 300) {\r\n        throw new Error(xhr.statusText);\r\n    }\r\n    return xhr.responseText;\r\n}\r\nfunction exists(filepath) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            return [2 /*return*/, true];\r\n        });\r\n    });\r\n}\r\nfunction existsSync(filepath) {\r\n    return true;\r\n}\r\nfunction dirname(filepath) {\r\n    return domResolve(filepath, '.');\r\n}\r\nvar sep = '/';\n\nvar fs = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    resolve: resolve,\n    readFile: readFile,\n    readFileSync: readFileSync,\n    exists: exists,\n    existsSync: existsSync,\n    dirname: dirname,\n    sep: sep\n});\n\nfunction isComparable(arg) {\r\n    return arg && isFunction(arg.equals);\r\n}\n\nfunction isTruthy(val, ctx) {\r\n    return !isFalsy(val, ctx);\r\n}\r\nfunction isFalsy(val, ctx) {\r\n    if (ctx.opts.jsTruthy) {\r\n        return !val;\r\n    }\r\n    else {\r\n        return val === false || undefined === val || val === null;\r\n    }\r\n}\n\nvar defaultOperators = {\r\n    '==': function (l, r) {\r\n        if (isComparable(l))\r\n            return l.equals(r);\r\n        if (isComparable(r))\r\n            return r.equals(l);\r\n        return l === r;\r\n    },\r\n    '!=': function (l, r) {\r\n        if (isComparable(l))\r\n            return !l.equals(r);\r\n        if (isComparable(r))\r\n            return !r.equals(l);\r\n        return l !== r;\r\n    },\r\n    '>': function (l, r) {\r\n        if (isComparable(l))\r\n            return l.gt(r);\r\n        if (isComparable(r))\r\n            return r.lt(l);\r\n        return l > r;\r\n    },\r\n    '<': function (l, r) {\r\n        if (isComparable(l))\r\n            return l.lt(r);\r\n        if (isComparable(r))\r\n            return r.gt(l);\r\n        return l < r;\r\n    },\r\n    '>=': function (l, r) {\r\n        if (isComparable(l))\r\n            return l.geq(r);\r\n        if (isComparable(r))\r\n            return r.leq(l);\r\n        return l >= r;\r\n    },\r\n    '<=': function (l, r) {\r\n        if (isComparable(l))\r\n            return l.leq(r);\r\n        if (isComparable(r))\r\n            return r.geq(l);\r\n        return l <= r;\r\n    },\r\n    'contains': function (l, r) {\r\n        return l && isFunction(l.indexOf) ? l.indexOf(r) > -1 : false;\r\n    },\r\n    'and': function (l, r, ctx) { return isTruthy(l, ctx) && isTruthy(r, ctx); },\r\n    'or': function (l, r, ctx) { return isTruthy(l, ctx) || isTruthy(r, ctx); }\r\n};\n\n// **DO NOT CHANGE THIS FILE**\r\n//\r\n// This file is generated by bin/character-gen.js\r\n// bitmask character types to boost performance\r\nvar TYPES = [0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 4, 4, 4, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 8, 0, 0, 0, 0, 8, 0, 0, 0, 64, 0, 65, 0, 0, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 0, 0, 2, 2, 2, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];\r\nvar IDENTIFIER = 1;\r\nvar BLANK = 4;\r\nvar QUOTE = 8;\r\nvar INLINE_BLANK = 16;\r\nvar NUMBER = 32;\r\nvar SIGN = 64;\r\nTYPES[160] = TYPES[5760] = TYPES[6158] = TYPES[8192] = TYPES[8193] = TYPES[8194] = TYPES[8195] = TYPES[8196] = TYPES[8197] = TYPES[8198] = TYPES[8199] = TYPES[8200] = TYPES[8201] = TYPES[8202] = TYPES[8232] = TYPES[8233] = TYPES[8239] = TYPES[8287] = TYPES[12288] = BLANK;\n\nfunction createTrie(operators) {\r\n    var e_1, _a;\r\n    var trie = {};\r\n    try {\r\n        for (var _b = __values(Object.entries(operators)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n            var _d = __read(_c.value, 2), name_1 = _d[0], handler = _d[1];\r\n            var node = trie;\r\n            for (var i = 0; i < name_1.length; i++) {\r\n                var c = name_1[i];\r\n                node[c] = node[c] || {};\r\n                if (i === name_1.length - 1 && (TYPES[name_1.charCodeAt(i)] & IDENTIFIER)) {\r\n                    node[c].needBoundary = true;\r\n                }\r\n                node = node[c];\r\n            }\r\n            node.handler = handler;\r\n            node.end = true;\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n    return trie;\r\n}\n\nvar defaultOptions = {\r\n    root: ['.'],\r\n    layouts: ['.'],\r\n    partials: ['.'],\r\n    relativeReference: true,\r\n    jekyllInclude: false,\r\n    cache: undefined,\r\n    extname: '',\r\n    fs: fs,\r\n    dynamicPartials: true,\r\n    jsTruthy: false,\r\n    trimTagRight: false,\r\n    trimTagLeft: false,\r\n    trimOutputRight: false,\r\n    trimOutputLeft: false,\r\n    greedy: true,\r\n    tagDelimiterLeft: '{%',\r\n    tagDelimiterRight: '%}',\r\n    outputDelimiterLeft: '{{',\r\n    outputDelimiterRight: '}}',\r\n    preserveTimezones: false,\r\n    strictFilters: false,\r\n    strictVariables: false,\r\n    ownPropertyOnly: false,\r\n    lenientIf: false,\r\n    globals: {},\r\n    keepOutputType: false,\r\n    operators: defaultOperators,\r\n    operatorsTrie: createTrie(defaultOperators)\r\n};\r\nfunction normalize(options) {\r\n    if (options.hasOwnProperty('operators')) {\r\n        options.operatorsTrie = createTrie(options.operators);\r\n    }\r\n    if (options.hasOwnProperty('root')) {\r\n        if (!options.hasOwnProperty('partials'))\r\n            options.partials = options.root;\r\n        if (!options.hasOwnProperty('layouts'))\r\n            options.layouts = options.root;\r\n    }\r\n    if (options.hasOwnProperty('cache')) {\r\n        var cache = void 0;\r\n        if (typeof options.cache === 'number')\r\n            cache = options.cache > 0 ? new LRU(options.cache) : undefined;\r\n        else if (typeof options.cache === 'object')\r\n            cache = options.cache;\r\n        else\r\n            cache = options.cache ? new LRU(1024) : undefined;\r\n        options.cache = cache;\r\n    }\r\n    options = __assign(__assign(__assign({}, defaultOptions), (options.jekyllInclude ? { dynamicPartials: false } : {})), options);\r\n    if (!options.fs.dirname && options.relativeReference) {\r\n        console.warn('[LiquidJS] `fs.dirname` is required for relativeReference, set relativeReference to `false` to suppress this warning, or provide implementation for `fs.dirname`');\r\n        options.relativeReference = false;\r\n    }\r\n    options.root = normalizeDirectoryList(options.root);\r\n    options.partials = normalizeDirectoryList(options.partials);\r\n    options.layouts = normalizeDirectoryList(options.layouts);\r\n    return options;\r\n}\r\nfunction normalizeDirectoryList(value) {\r\n    var list = [];\r\n    if (isArray(value))\r\n        list = value;\r\n    if (isString(value))\r\n        list = [value];\r\n    return list;\r\n}\n\nvar LiquidError = /** @class */ (function (_super) {\r\n    __extends(LiquidError, _super);\r\n    function LiquidError(err, token) {\r\n        var _this = _super.call(this, err.message) || this;\r\n        _this.originalError = err;\r\n        _this.token = token;\r\n        _this.context = '';\r\n        return _this;\r\n    }\r\n    LiquidError.prototype.update = function () {\r\n        var err = this.originalError;\r\n        this.context = mkContext(this.token);\r\n        this.message = mkMessage(err.message, this.token);\r\n        this.stack = this.message + '\\n' + this.context +\r\n            '\\n' + this.stack + '\\nFrom ' + err.stack;\r\n    };\r\n    return LiquidError;\r\n}(Error));\r\nvar TokenizationError = /** @class */ (function (_super) {\r\n    __extends(TokenizationError, _super);\r\n    function TokenizationError(message, token) {\r\n        var _this = _super.call(this, new Error(message), token) || this;\r\n        _this.name = 'TokenizationError';\r\n        _super.prototype.update.call(_this);\r\n        return _this;\r\n    }\r\n    return TokenizationError;\r\n}(LiquidError));\r\nvar ParseError = /** @class */ (function (_super) {\r\n    __extends(ParseError, _super);\r\n    function ParseError(err, token) {\r\n        var _this = _super.call(this, err, token) || this;\r\n        _this.name = 'ParseError';\r\n        _this.message = err.message;\r\n        _super.prototype.update.call(_this);\r\n        return _this;\r\n    }\r\n    return ParseError;\r\n}(LiquidError));\r\nvar RenderError = /** @class */ (function (_super) {\r\n    __extends(RenderError, _super);\r\n    function RenderError(err, tpl) {\r\n        var _this = _super.call(this, err, tpl.token) || this;\r\n        _this.name = 'RenderError';\r\n        _this.message = err.message;\r\n        _super.prototype.update.call(_this);\r\n        return _this;\r\n    }\r\n    RenderError.is = function (obj) {\r\n        return obj.name === 'RenderError';\r\n    };\r\n    return RenderError;\r\n}(LiquidError));\r\nvar UndefinedVariableError = /** @class */ (function (_super) {\r\n    __extends(UndefinedVariableError, _super);\r\n    function UndefinedVariableError(err, token) {\r\n        var _this = _super.call(this, err, token) || this;\r\n        _this.name = 'UndefinedVariableError';\r\n        _this.message = err.message;\r\n        _super.prototype.update.call(_this);\r\n        return _this;\r\n    }\r\n    return UndefinedVariableError;\r\n}(LiquidError));\r\n// only used internally; raised where we don't have token information,\r\n// so it can't be an UndefinedVariableError.\r\nvar InternalUndefinedVariableError = /** @class */ (function (_super) {\r\n    __extends(InternalUndefinedVariableError, _super);\r\n    function InternalUndefinedVariableError(variableName) {\r\n        var _this = _super.call(this, \"undefined variable: \".concat(variableName)) || this;\r\n        _this.name = 'InternalUndefinedVariableError';\r\n        _this.variableName = variableName;\r\n        return _this;\r\n    }\r\n    return InternalUndefinedVariableError;\r\n}(Error));\r\nvar AssertionError = /** @class */ (function (_super) {\r\n    __extends(AssertionError, _super);\r\n    function AssertionError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.name = 'AssertionError';\r\n        _this.message = message + '';\r\n        return _this;\r\n    }\r\n    return AssertionError;\r\n}(Error));\r\nfunction mkContext(token) {\r\n    var _a = __read(token.getPosition(), 1), line = _a[0];\r\n    var lines = token.input.split('\\n');\r\n    var begin = Math.max(line - 2, 1);\r\n    var end = Math.min(line + 3, lines.length);\r\n    var context = range(begin, end + 1)\r\n        .map(function (lineNumber) {\r\n        var indicator = (lineNumber === line) ? '>> ' : '   ';\r\n        var num = padStart(String(lineNumber), String(end).length);\r\n        var text = lines[lineNumber - 1];\r\n        return \"\".concat(indicator).concat(num, \"| \").concat(text);\r\n    })\r\n        .join('\\n');\r\n    return context;\r\n}\r\nfunction mkMessage(msg, token) {\r\n    if (token.file)\r\n        msg += \", file:\".concat(token.file);\r\n    var _a = __read(token.getPosition(), 2), line = _a[0], col = _a[1];\r\n    msg += \", line:\".concat(line, \", col:\").concat(col);\r\n    return msg;\r\n}\n\nvar Context = /** @class */ (function () {\r\n    function Context(env, opts, renderOptions) {\r\n        if (env === void 0) { env = {}; }\r\n        if (opts === void 0) { opts = defaultOptions; }\r\n        if (renderOptions === void 0) { renderOptions = {}; }\r\n        var _a, _b;\r\n        /**\r\n         * insert a Context-level empty scope,\r\n         * for tags like `{% capture %}` `{% assign %}` to operate\r\n         */\r\n        this.scopes = [{}];\r\n        this.registers = {};\r\n        this.sync = !!renderOptions.sync;\r\n        this.opts = opts;\r\n        this.globals = (_a = renderOptions.globals) !== null && _a !== void 0 ? _a : opts.globals;\r\n        this.environments = env;\r\n        this.strictVariables = (_b = renderOptions.strictVariables) !== null && _b !== void 0 ? _b : this.opts.strictVariables;\r\n    }\r\n    Context.prototype.getRegister = function (key) {\r\n        return (this.registers[key] = this.registers[key] || {});\r\n    };\r\n    Context.prototype.setRegister = function (key, value) {\r\n        return (this.registers[key] = value);\r\n    };\r\n    Context.prototype.saveRegister = function () {\r\n        var _this = this;\r\n        var keys = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            keys[_i] = arguments[_i];\r\n        }\r\n        return keys.map(function (key) { return [key, _this.getRegister(key)]; });\r\n    };\r\n    Context.prototype.restoreRegister = function (keyValues) {\r\n        var _this = this;\r\n        return keyValues.forEach(function (_a) {\r\n            var _b = __read(_a, 2), key = _b[0], value = _b[1];\r\n            return _this.setRegister(key, value);\r\n        });\r\n    };\r\n    Context.prototype.getAll = function () {\r\n        return __spreadArray([this.globals, this.environments], __read(this.scopes), false).reduce(function (ctx, val) { return __assign(ctx, val); }, {});\r\n    };\r\n    Context.prototype.get = function (paths) {\r\n        var scope = this.findScope(paths[0]);\r\n        return this.getFromScope(scope, paths);\r\n    };\r\n    Context.prototype.getFromScope = function (scope, paths) {\r\n        var _this = this;\r\n        if (isString(paths))\r\n            paths = paths.split('.');\r\n        return paths.reduce(function (scope, path, i) {\r\n            scope = readProperty(scope, path, _this.opts.ownPropertyOnly);\r\n            if (isNil(scope) && _this.strictVariables) {\r\n                throw new InternalUndefinedVariableError(paths.slice(0, i + 1).join('.'));\r\n            }\r\n            return scope;\r\n        }, scope);\r\n    };\r\n    Context.prototype.push = function (ctx) {\r\n        return this.scopes.push(ctx);\r\n    };\r\n    Context.prototype.pop = function () {\r\n        return this.scopes.pop();\r\n    };\r\n    Context.prototype.bottom = function () {\r\n        return this.scopes[0];\r\n    };\r\n    Context.prototype.findScope = function (key) {\r\n        for (var i = this.scopes.length - 1; i >= 0; i--) {\r\n            var candidate = this.scopes[i];\r\n            if (key in candidate)\r\n                return candidate;\r\n        }\r\n        if (key in this.environments)\r\n            return this.environments;\r\n        return this.globals;\r\n    };\r\n    return Context;\r\n}());\r\nfunction readProperty(obj, key, ownPropertyOnly) {\r\n    if (isNil(obj))\r\n        return obj;\r\n    obj = toLiquid(obj);\r\n    if (isArray(obj) && key < 0)\r\n        return obj[obj.length + +key];\r\n    var jsProperty = readJSProperty(obj, key, ownPropertyOnly);\r\n    if (jsProperty === undefined && obj instanceof Drop)\r\n        return obj.liquidMethodMissing(key);\r\n    if (isFunction(jsProperty))\r\n        return jsProperty.call(obj);\r\n    if (key === 'size')\r\n        return readSize(obj);\r\n    else if (key === 'first')\r\n        return readFirst(obj);\r\n    else if (key === 'last')\r\n        return readLast(obj);\r\n    return jsProperty;\r\n}\r\nfunction readJSProperty(obj, key, ownPropertyOnly) {\r\n    if (ownPropertyOnly && !Object.hasOwnProperty.call(obj, key))\r\n        return undefined;\r\n    return obj[key];\r\n}\r\nfunction readFirst(obj) {\r\n    if (isArray(obj))\r\n        return obj[0];\r\n    return obj['first'];\r\n}\r\nfunction readLast(obj) {\r\n    if (isArray(obj))\r\n        return obj[obj.length - 1];\r\n    return obj['last'];\r\n}\r\nfunction readSize(obj) {\r\n    if (obj.hasOwnProperty('size') || obj['size'] !== undefined)\r\n        return obj['size'];\r\n    if (isArray(obj) || isString(obj))\r\n        return obj.length;\r\n    if (typeof obj === 'object')\r\n        return Object.keys(obj).length;\r\n}\n\nfunction assert(predicate, message) {\r\n    if (!predicate) {\r\n        var msg = typeof message === 'function'\r\n            ? message()\r\n            : (message || \"expect \".concat(predicate, \" to be true\"));\r\n        throw new AssertionError(msg);\r\n    }\r\n}\n\nvar LookupType;\r\n(function (LookupType) {\r\n    LookupType[\"Partials\"] = \"partials\";\r\n    LookupType[\"Layouts\"] = \"layouts\";\r\n    LookupType[\"Root\"] = \"root\";\r\n})(LookupType || (LookupType = {}));\r\nvar Loader = /** @class */ (function () {\r\n    function Loader(options) {\r\n        this.options = options;\r\n        if (options.relativeReference) {\r\n            var sep = options.fs.sep;\r\n            assert(sep, '`fs.sep` is required for relative reference');\r\n            var rRelativePath_1 = new RegExp(['.' + sep, '..' + sep, './', '../'].map(function (prefix) { return escapeRegex(prefix); }).join('|'));\r\n            this.shouldLoadRelative = function (referencedFile) { return rRelativePath_1.test(referencedFile); };\r\n        }\r\n        else {\r\n            this.shouldLoadRelative = function (referencedFile) { return false; };\r\n        }\r\n        this.contains = this.options.fs.contains || (function () { return true; });\r\n    }\r\n    Loader.prototype.lookup = function (file, type, sync, currentFile) {\r\n        var fs, dirs, _a, _b, filepath, _c, e_1_1;\r\n        var e_1, _d;\r\n        return __generator(this, function (_e) {\r\n            switch (_e.label) {\r\n                case 0:\r\n                    fs = this.options.fs;\r\n                    dirs = this.options[type];\r\n                    _e.label = 1;\r\n                case 1:\r\n                    _e.trys.push([1, 8, 9, 10]);\r\n                    _a = __values(this.candidates(file, dirs, currentFile, type !== LookupType.Root)), _b = _a.next();\r\n                    _e.label = 2;\r\n                case 2:\r\n                    if (!!_b.done) return [3 /*break*/, 7];\r\n                    filepath = _b.value;\r\n                    if (!sync) return [3 /*break*/, 3];\r\n                    _c = fs.existsSync(filepath);\r\n                    return [3 /*break*/, 5];\r\n                case 3: return [4 /*yield*/, fs.exists(filepath)];\r\n                case 4:\r\n                    _c = _e.sent();\r\n                    _e.label = 5;\r\n                case 5:\r\n                    if (_c)\r\n                        return [2 /*return*/, filepath];\r\n                    _e.label = 6;\r\n                case 6:\r\n                    _b = _a.next();\r\n                    return [3 /*break*/, 2];\r\n                case 7: return [3 /*break*/, 10];\r\n                case 8:\r\n                    e_1_1 = _e.sent();\r\n                    e_1 = { error: e_1_1 };\r\n                    return [3 /*break*/, 10];\r\n                case 9:\r\n                    try {\r\n                        if (_b && !_b.done && (_d = _a.return)) _d.call(_a);\r\n                    }\r\n                    finally { if (e_1) throw e_1.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 10: throw this.lookupError(file, dirs);\r\n            }\r\n        });\r\n    };\r\n    Loader.prototype.candidates = function (file, dirs, currentFile, enforceRoot) {\r\n        var _a, fs, extname, referenced, dirs_1, dirs_1_1, dir, e_2_1, dirs_2, dirs_2_1, dir, referenced, e_3_1, filepath;\r\n        var e_2, _b, e_3, _c;\r\n        return __generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0:\r\n                    _a = this.options, fs = _a.fs, extname = _a.extname;\r\n                    if (!(this.shouldLoadRelative(file) && currentFile)) return [3 /*break*/, 8];\r\n                    referenced = fs.resolve(this.dirname(currentFile), file, extname);\r\n                    _d.label = 1;\r\n                case 1:\r\n                    _d.trys.push([1, 6, 7, 8]);\r\n                    dirs_1 = __values(dirs), dirs_1_1 = dirs_1.next();\r\n                    _d.label = 2;\r\n                case 2:\r\n                    if (!!dirs_1_1.done) return [3 /*break*/, 5];\r\n                    dir = dirs_1_1.value;\r\n                    if (!(!enforceRoot || this.contains(dir, referenced))) return [3 /*break*/, 4];\r\n                    // the relatively referenced file is within one of root dirs\r\n                    return [4 /*yield*/, referenced];\r\n                case 3:\r\n                    // the relatively referenced file is within one of root dirs\r\n                    _d.sent();\r\n                    return [3 /*break*/, 5];\r\n                case 4:\r\n                    dirs_1_1 = dirs_1.next();\r\n                    return [3 /*break*/, 2];\r\n                case 5: return [3 /*break*/, 8];\r\n                case 6:\r\n                    e_2_1 = _d.sent();\r\n                    e_2 = { error: e_2_1 };\r\n                    return [3 /*break*/, 8];\r\n                case 7:\r\n                    try {\r\n                        if (dirs_1_1 && !dirs_1_1.done && (_b = dirs_1.return)) _b.call(dirs_1);\r\n                    }\r\n                    finally { if (e_2) throw e_2.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 8:\r\n                    _d.trys.push([8, 13, 14, 15]);\r\n                    dirs_2 = __values(dirs), dirs_2_1 = dirs_2.next();\r\n                    _d.label = 9;\r\n                case 9:\r\n                    if (!!dirs_2_1.done) return [3 /*break*/, 12];\r\n                    dir = dirs_2_1.value;\r\n                    referenced = fs.resolve(dir, file, extname);\r\n                    if (!(!enforceRoot || this.contains(dir, referenced))) return [3 /*break*/, 11];\r\n                    return [4 /*yield*/, referenced];\r\n                case 10:\r\n                    _d.sent();\r\n                    _d.label = 11;\r\n                case 11:\r\n                    dirs_2_1 = dirs_2.next();\r\n                    return [3 /*break*/, 9];\r\n                case 12: return [3 /*break*/, 15];\r\n                case 13:\r\n                    e_3_1 = _d.sent();\r\n                    e_3 = { error: e_3_1 };\r\n                    return [3 /*break*/, 15];\r\n                case 14:\r\n                    try {\r\n                        if (dirs_2_1 && !dirs_2_1.done && (_c = dirs_2.return)) _c.call(dirs_2);\r\n                    }\r\n                    finally { if (e_3) throw e_3.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 15:\r\n                    if (!(fs.fallback !== undefined)) return [3 /*break*/, 17];\r\n                    filepath = fs.fallback(file);\r\n                    if (!(filepath !== undefined)) return [3 /*break*/, 17];\r\n                    return [4 /*yield*/, filepath];\r\n                case 16:\r\n                    _d.sent();\r\n                    _d.label = 17;\r\n                case 17: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    Loader.prototype.dirname = function (path) {\r\n        var fs = this.options.fs;\r\n        assert(fs.dirname, '`fs.dirname` is required for relative reference');\r\n        return fs.dirname(path);\r\n    };\r\n    Loader.prototype.lookupError = function (file, roots) {\r\n        var err = new Error('ENOENT');\r\n        err.message = \"ENOENT: Failed to lookup \\\"\".concat(file, \"\\\" in \\\"\").concat(roots, \"\\\"\");\r\n        err.code = 'ENOENT';\r\n        return err;\r\n    };\r\n    return Loader;\r\n}());\n\nvar SimpleEmitter = /** @class */ (function () {\r\n    function SimpleEmitter() {\r\n        this.buffer = '';\r\n    }\r\n    SimpleEmitter.prototype.write = function (html) {\r\n        this.buffer += stringify(html);\r\n    };\r\n    return SimpleEmitter;\r\n}());\n\nvar StreamedEmitter = /** @class */ (function () {\r\n    function StreamedEmitter() {\r\n        this.buffer = '';\r\n        this.stream = null;\r\n        throw new Error('streaming not supported in browser');\r\n    }\r\n    return StreamedEmitter;\r\n}());\n\nfunction createResolvedThenable(value) {\r\n    var ret = {\r\n        then: function (resolve) { return resolve(value); },\r\n        catch: function () { return ret; }\r\n    };\r\n    return ret;\r\n}\r\nfunction createRejectedThenable(err) {\r\n    var ret = {\r\n        then: function (resolve, reject) {\r\n            if (reject)\r\n                return reject(err);\r\n            return ret;\r\n        },\r\n        catch: function (reject) { return reject(err); }\r\n    };\r\n    return ret;\r\n}\r\nfunction isThenable(val) {\r\n    return val && isFunction(val.then);\r\n}\r\nfunction isAsyncIterator(val) {\r\n    return val && isFunction(val.next) && isFunction(val.throw) && isFunction(val.return);\r\n}\r\n// convert an async iterator to a thenable (Promise compatible)\r\nfunction toThenable(val) {\r\n    if (isThenable(val))\r\n        return val;\r\n    if (isAsyncIterator(val))\r\n        return reduce();\r\n    return createResolvedThenable(val);\r\n    function reduce(prev) {\r\n        var state;\r\n        try {\r\n            state = val.next(prev);\r\n        }\r\n        catch (err) {\r\n            return createRejectedThenable(err);\r\n        }\r\n        if (state.done)\r\n            return createResolvedThenable(state.value);\r\n        return toThenable(state.value).then(reduce, function (err) {\r\n            var state;\r\n            try {\r\n                state = val.throw(err);\r\n            }\r\n            catch (e) {\r\n                return createRejectedThenable(e);\r\n            }\r\n            if (state.done)\r\n                return createResolvedThenable(state.value);\r\n            return reduce(state.value);\r\n        });\r\n    }\r\n}\r\nfunction toPromise(val) {\r\n    return Promise.resolve(toThenable(val));\r\n}\r\n// get the value of async iterator in synchronous manner\r\nfunction toValue(val) {\r\n    var ret;\r\n    toThenable(val)\r\n        .then(function (x) {\r\n        ret = x;\r\n        return createResolvedThenable(ret);\r\n    })\r\n        .catch(function (err) {\r\n        throw err;\r\n    });\r\n    return ret;\r\n}\n\nvar KeepingTypeEmitter = /** @class */ (function () {\r\n    function KeepingTypeEmitter() {\r\n        this.buffer = '';\r\n    }\r\n    KeepingTypeEmitter.prototype.write = function (html) {\r\n        html = toValue$1(html);\r\n        // This will only preserve the type if the value is isolated.\r\n        // I.E:\r\n        // {{ my-port }} -> 42\r\n        // {{ my-host }}:{{ my-port }} -> 'host:42'\r\n        if (typeof html !== 'string' && this.buffer === '') {\r\n            this.buffer = html;\r\n        }\r\n        else {\r\n            this.buffer = stringify(this.buffer) + stringify(html);\r\n        }\r\n    };\r\n    return KeepingTypeEmitter;\r\n}());\n\nvar Render = /** @class */ (function () {\r\n    function Render() {\r\n    }\r\n    Render.prototype.renderTemplatesToNodeStream = function (templates, ctx) {\r\n        var _this = this;\r\n        var emitter = new StreamedEmitter();\r\n        Promise.resolve().then(function () { return toThenable(_this.renderTemplates(templates, ctx, emitter)); })\r\n            .then(function () { return emitter.end(); }, function (err) { return emitter.error(err); });\r\n        return emitter.stream;\r\n    };\r\n    Render.prototype.renderTemplates = function (templates, ctx, emitter) {\r\n        var templates_1, templates_1_1, tpl, html, e_1, err, e_2_1;\r\n        var e_2, _a;\r\n        return __generator(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0:\r\n                    if (!emitter) {\r\n                        emitter = ctx.opts.keepOutputType ? new KeepingTypeEmitter() : new SimpleEmitter();\r\n                    }\r\n                    _b.label = 1;\r\n                case 1:\r\n                    _b.trys.push([1, 8, 9, 10]);\r\n                    templates_1 = __values(templates), templates_1_1 = templates_1.next();\r\n                    _b.label = 2;\r\n                case 2:\r\n                    if (!!templates_1_1.done) return [3 /*break*/, 7];\r\n                    tpl = templates_1_1.value;\r\n                    _b.label = 3;\r\n                case 3:\r\n                    _b.trys.push([3, 5, , 6]);\r\n                    return [4 /*yield*/, tpl.render(ctx, emitter)\r\n                        // if not, it'll return an `html`, write to the emitter for it\r\n                    ];\r\n                case 4:\r\n                    html = _b.sent();\r\n                    // if not, it'll return an `html`, write to the emitter for it\r\n                    html && emitter.write(html);\r\n                    if (emitter['break'] || emitter['continue'])\r\n                        return [3 /*break*/, 7];\r\n                    return [3 /*break*/, 6];\r\n                case 5:\r\n                    e_1 = _b.sent();\r\n                    err = RenderError.is(e_1) ? e_1 : new RenderError(e_1, tpl);\r\n                    throw err;\r\n                case 6:\r\n                    templates_1_1 = templates_1.next();\r\n                    return [3 /*break*/, 2];\r\n                case 7: return [3 /*break*/, 10];\r\n                case 8:\r\n                    e_2_1 = _b.sent();\r\n                    e_2 = { error: e_2_1 };\r\n                    return [3 /*break*/, 10];\r\n                case 9:\r\n                    try {\r\n                        if (templates_1_1 && !templates_1_1.done && (_a = templates_1.return)) _a.call(templates_1);\r\n                    }\r\n                    finally { if (e_2) throw e_2.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 10: return [2 /*return*/, emitter.buffer];\r\n            }\r\n        });\r\n    };\r\n    return Render;\r\n}());\n\nvar TokenKind;\r\n(function (TokenKind) {\r\n    TokenKind[TokenKind[\"Number\"] = 1] = \"Number\";\r\n    TokenKind[TokenKind[\"Literal\"] = 2] = \"Literal\";\r\n    TokenKind[TokenKind[\"Tag\"] = 4] = \"Tag\";\r\n    TokenKind[TokenKind[\"Output\"] = 8] = \"Output\";\r\n    TokenKind[TokenKind[\"HTML\"] = 16] = \"HTML\";\r\n    TokenKind[TokenKind[\"Filter\"] = 32] = \"Filter\";\r\n    TokenKind[TokenKind[\"Hash\"] = 64] = \"Hash\";\r\n    TokenKind[TokenKind[\"PropertyAccess\"] = 128] = \"PropertyAccess\";\r\n    TokenKind[TokenKind[\"Word\"] = 256] = \"Word\";\r\n    TokenKind[TokenKind[\"Range\"] = 512] = \"Range\";\r\n    TokenKind[TokenKind[\"Quoted\"] = 1024] = \"Quoted\";\r\n    TokenKind[TokenKind[\"Operator\"] = 2048] = \"Operator\";\r\n    TokenKind[TokenKind[\"Delimited\"] = 12] = \"Delimited\";\r\n})(TokenKind || (TokenKind = {}));\n\nfunction isDelimitedToken(val) {\r\n    return !!(getKind(val) & TokenKind.Delimited);\r\n}\r\nfunction isOperatorToken(val) {\r\n    return getKind(val) === TokenKind.Operator;\r\n}\r\nfunction isHTMLToken(val) {\r\n    return getKind(val) === TokenKind.HTML;\r\n}\r\nfunction isOutputToken(val) {\r\n    return getKind(val) === TokenKind.Output;\r\n}\r\nfunction isTagToken(val) {\r\n    return getKind(val) === TokenKind.Tag;\r\n}\r\nfunction isQuotedToken(val) {\r\n    return getKind(val) === TokenKind.Quoted;\r\n}\r\nfunction isLiteralToken(val) {\r\n    return getKind(val) === TokenKind.Literal;\r\n}\r\nfunction isNumberToken(val) {\r\n    return getKind(val) === TokenKind.Number;\r\n}\r\nfunction isPropertyAccessToken(val) {\r\n    return getKind(val) === TokenKind.PropertyAccess;\r\n}\r\nfunction isWordToken(val) {\r\n    return getKind(val) === TokenKind.Word;\r\n}\r\nfunction isRangeToken(val) {\r\n    return getKind(val) === TokenKind.Range;\r\n}\r\nfunction getKind(val) {\r\n    return val ? val.kind : -1;\r\n}\n\nvar typeGuards = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    isDelimitedToken: isDelimitedToken,\n    isOperatorToken: isOperatorToken,\n    isHTMLToken: isHTMLToken,\n    isOutputToken: isOutputToken,\n    isTagToken: isTagToken,\n    isQuotedToken: isQuotedToken,\n    isLiteralToken: isLiteralToken,\n    isNumberToken: isNumberToken,\n    isPropertyAccessToken: isPropertyAccessToken,\n    isWordToken: isWordToken,\n    isRangeToken: isRangeToken\n});\n\nvar ParseStream = /** @class */ (function () {\r\n    function ParseStream(tokens, parseToken) {\r\n        this.handlers = {};\r\n        this.stopRequested = false;\r\n        this.tokens = tokens;\r\n        this.parseToken = parseToken;\r\n    }\r\n    ParseStream.prototype.on = function (name, cb) {\r\n        this.handlers[name] = cb;\r\n        return this;\r\n    };\r\n    ParseStream.prototype.trigger = function (event, arg) {\r\n        var h = this.handlers[event];\r\n        return h ? (h.call(this, arg), true) : false;\r\n    };\r\n    ParseStream.prototype.start = function () {\r\n        this.trigger('start');\r\n        var token;\r\n        while (!this.stopRequested && (token = this.tokens.shift())) {\r\n            if (this.trigger('token', token))\r\n                continue;\r\n            if (isTagToken(token) && this.trigger(\"tag:\".concat(token.name), token)) {\r\n                continue;\r\n            }\r\n            var template = this.parseToken(token, this.tokens);\r\n            this.trigger('template', template);\r\n        }\r\n        if (!this.stopRequested)\r\n            this.trigger('end');\r\n        return this;\r\n    };\r\n    ParseStream.prototype.stop = function () {\r\n        this.stopRequested = true;\r\n        return this;\r\n    };\r\n    return ParseStream;\r\n}());\n\nvar TemplateImpl = /** @class */ (function () {\r\n    function TemplateImpl(token) {\r\n        this.token = token;\r\n    }\r\n    return TemplateImpl;\r\n}());\n\nvar NullDrop = /** @class */ (function (_super) {\r\n    __extends(NullDrop, _super);\r\n    function NullDrop() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    NullDrop.prototype.equals = function (value) {\r\n        return isNil(toValue$1(value));\r\n    };\r\n    NullDrop.prototype.gt = function () {\r\n        return false;\r\n    };\r\n    NullDrop.prototype.geq = function () {\r\n        return false;\r\n    };\r\n    NullDrop.prototype.lt = function () {\r\n        return false;\r\n    };\r\n    NullDrop.prototype.leq = function () {\r\n        return false;\r\n    };\r\n    NullDrop.prototype.valueOf = function () {\r\n        return null;\r\n    };\r\n    return NullDrop;\r\n}(Drop));\n\nvar EmptyDrop = /** @class */ (function (_super) {\r\n    __extends(EmptyDrop, _super);\r\n    function EmptyDrop() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    EmptyDrop.prototype.equals = function (value) {\r\n        if (value instanceof EmptyDrop)\r\n            return false;\r\n        value = toValue$1(value);\r\n        if (isString(value) || isArray(value))\r\n            return value.length === 0;\r\n        if (isObject(value))\r\n            return Object.keys(value).length === 0;\r\n        return false;\r\n    };\r\n    EmptyDrop.prototype.gt = function () {\r\n        return false;\r\n    };\r\n    EmptyDrop.prototype.geq = function () {\r\n        return false;\r\n    };\r\n    EmptyDrop.prototype.lt = function () {\r\n        return false;\r\n    };\r\n    EmptyDrop.prototype.leq = function () {\r\n        return false;\r\n    };\r\n    EmptyDrop.prototype.valueOf = function () {\r\n        return '';\r\n    };\r\n    return EmptyDrop;\r\n}(Drop));\n\nvar BlankDrop = /** @class */ (function (_super) {\r\n    __extends(BlankDrop, _super);\r\n    function BlankDrop() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    BlankDrop.prototype.equals = function (value) {\r\n        if (value === false)\r\n            return true;\r\n        if (isNil(toValue$1(value)))\r\n            return true;\r\n        if (isString(value))\r\n            return /^\\s*$/.test(value);\r\n        return _super.prototype.equals.call(this, value);\r\n    };\r\n    return BlankDrop;\r\n}(EmptyDrop));\n\nvar nil = new NullDrop();\r\nvar literalValues = {\r\n    'true': true,\r\n    'false': false,\r\n    'nil': nil,\r\n    'null': nil,\r\n    'empty': new EmptyDrop(),\r\n    'blank': new BlankDrop()\r\n};\n\nvar rHex = /[\\da-fA-F]/;\r\nvar rOct = /[0-7]/;\r\nvar escapeChar = {\r\n    b: '\\b',\r\n    f: '\\f',\r\n    n: '\\n',\r\n    r: '\\r',\r\n    t: '\\t',\r\n    v: '\\x0B'\r\n};\r\nfunction hexVal(c) {\r\n    var code = c.charCodeAt(0);\r\n    if (code >= 97)\r\n        return code - 87;\r\n    if (code >= 65)\r\n        return code - 55;\r\n    return code - 48;\r\n}\r\nfunction parseStringLiteral(str) {\r\n    var ret = '';\r\n    for (var i = 1; i < str.length - 1; i++) {\r\n        if (str[i] !== '\\\\') {\r\n            ret += str[i];\r\n            continue;\r\n        }\r\n        if (escapeChar[str[i + 1]] !== undefined) {\r\n            ret += escapeChar[str[++i]];\r\n        }\r\n        else if (str[i + 1] === 'u') {\r\n            var val = 0;\r\n            var j = i + 2;\r\n            while (j <= i + 5 && rHex.test(str[j])) {\r\n                val = val * 16 + hexVal(str[j++]);\r\n            }\r\n            i = j - 1;\r\n            ret += String.fromCharCode(val);\r\n        }\r\n        else if (!rOct.test(str[i + 1])) {\r\n            ret += str[++i];\r\n        }\r\n        else {\r\n            var j = i + 1;\r\n            var val = 0;\r\n            while (j <= i + 3 && rOct.test(str[j])) {\r\n                val = val * 8 + hexVal(str[j++]);\r\n            }\r\n            i = j - 1;\r\n            ret += String.fromCharCode(val);\r\n        }\r\n    }\r\n    return ret;\r\n}\n\nvar Expression = /** @class */ (function () {\r\n    function Expression(tokens) {\r\n        this.postfix = __spreadArray([], __read(toPostfix(tokens)), false);\r\n    }\r\n    Expression.prototype.evaluate = function (ctx, lenient) {\r\n        var operands, _a, _b, token, r, l, result, _c, _d, e_1_1;\r\n        var e_1, _e;\r\n        return __generator(this, function (_f) {\r\n            switch (_f.label) {\r\n                case 0:\r\n                    assert(ctx, 'unable to evaluate: context not defined');\r\n                    operands = [];\r\n                    _f.label = 1;\r\n                case 1:\r\n                    _f.trys.push([1, 9, 10, 11]);\r\n                    _a = __values(this.postfix), _b = _a.next();\r\n                    _f.label = 2;\r\n                case 2:\r\n                    if (!!_b.done) return [3 /*break*/, 8];\r\n                    token = _b.value;\r\n                    if (!isOperatorToken(token)) return [3 /*break*/, 5];\r\n                    return [4 /*yield*/, operands.pop()];\r\n                case 3:\r\n                    r = _f.sent();\r\n                    return [4 /*yield*/, operands.pop()];\r\n                case 4:\r\n                    l = _f.sent();\r\n                    result = evalOperatorToken(ctx.opts.operators, token, l, r, ctx);\r\n                    operands.push(result);\r\n                    return [3 /*break*/, 7];\r\n                case 5:\r\n                    _d = (_c = operands).push;\r\n                    return [4 /*yield*/, evalToken(token, ctx, lenient && this.postfix.length === 1)];\r\n                case 6:\r\n                    _d.apply(_c, [_f.sent()]);\r\n                    _f.label = 7;\r\n                case 7:\r\n                    _b = _a.next();\r\n                    return [3 /*break*/, 2];\r\n                case 8: return [3 /*break*/, 11];\r\n                case 9:\r\n                    e_1_1 = _f.sent();\r\n                    e_1 = { error: e_1_1 };\r\n                    return [3 /*break*/, 11];\r\n                case 10:\r\n                    try {\r\n                        if (_b && !_b.done && (_e = _a.return)) _e.call(_a);\r\n                    }\r\n                    finally { if (e_1) throw e_1.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 11: return [2 /*return*/, operands[0]];\r\n            }\r\n        });\r\n    };\r\n    return Expression;\r\n}());\r\nfunction evalToken(token, ctx, lenient) {\r\n    if (lenient === void 0) { lenient = false; }\r\n    if (isPropertyAccessToken(token))\r\n        return evalPropertyAccessToken(token, ctx, lenient);\r\n    if (isRangeToken(token))\r\n        return evalRangeToken(token, ctx);\r\n    if (isLiteralToken(token))\r\n        return evalLiteralToken(token);\r\n    if (isNumberToken(token))\r\n        return evalNumberToken(token);\r\n    if (isWordToken(token))\r\n        return token.getText();\r\n    if (isQuotedToken(token))\r\n        return evalQuotedToken(token);\r\n}\r\nfunction evalPropertyAccessToken(token, ctx, lenient) {\r\n    var props = token.props.map(function (prop) { return evalToken(prop, ctx, false); });\r\n    try {\r\n        return ctx.get(__spreadArray([token.propertyName], __read(props), false));\r\n    }\r\n    catch (e) {\r\n        if (lenient && e.name === 'InternalUndefinedVariableError')\r\n            return null;\r\n        throw (new UndefinedVariableError(e, token));\r\n    }\r\n}\r\nfunction evalNumberToken(token) {\r\n    var str = token.whole.content + '.' + (token.decimal ? token.decimal.content : '');\r\n    return Number(str);\r\n}\r\nfunction evalQuotedToken(token) {\r\n    return parseStringLiteral(token.getText());\r\n}\r\nfunction evalOperatorToken(operators, token, lhs, rhs, ctx) {\r\n    var impl = operators[token.operator];\r\n    return impl(lhs, rhs, ctx);\r\n}\r\nfunction evalLiteralToken(token) {\r\n    return literalValues[token.literal];\r\n}\r\nfunction evalRangeToken(token, ctx) {\r\n    var low = evalToken(token.lhs, ctx);\r\n    var high = evalToken(token.rhs, ctx);\r\n    return range(+low, +high + 1);\r\n}\r\nfunction toPostfix(tokens) {\r\n    var ops, tokens_1, tokens_1_1, token, e_2_1;\r\n    var e_2, _a;\r\n    return __generator(this, function (_b) {\r\n        switch (_b.label) {\r\n            case 0:\r\n                ops = [];\r\n                _b.label = 1;\r\n            case 1:\r\n                _b.trys.push([1, 10, 11, 12]);\r\n                tokens_1 = __values(tokens), tokens_1_1 = tokens_1.next();\r\n                _b.label = 2;\r\n            case 2:\r\n                if (!!tokens_1_1.done) return [3 /*break*/, 9];\r\n                token = tokens_1_1.value;\r\n                if (!isOperatorToken(token)) return [3 /*break*/, 6];\r\n                _b.label = 3;\r\n            case 3:\r\n                if (!(ops.length && ops[ops.length - 1].getPrecedence() > token.getPrecedence())) return [3 /*break*/, 5];\r\n                return [4 /*yield*/, ops.pop()];\r\n            case 4:\r\n                _b.sent();\r\n                return [3 /*break*/, 3];\r\n            case 5:\r\n                ops.push(token);\r\n                return [3 /*break*/, 8];\r\n            case 6: return [4 /*yield*/, token];\r\n            case 7:\r\n                _b.sent();\r\n                _b.label = 8;\r\n            case 8:\r\n                tokens_1_1 = tokens_1.next();\r\n                return [3 /*break*/, 2];\r\n            case 9: return [3 /*break*/, 12];\r\n            case 10:\r\n                e_2_1 = _b.sent();\r\n                e_2 = { error: e_2_1 };\r\n                return [3 /*break*/, 12];\r\n            case 11:\r\n                try {\r\n                    if (tokens_1_1 && !tokens_1_1.done && (_a = tokens_1.return)) _a.call(tokens_1);\r\n                }\r\n                finally { if (e_2) throw e_2.error; }\r\n                return [7 /*endfinally*/];\r\n            case 12:\r\n                if (!ops.length) return [3 /*break*/, 14];\r\n                return [4 /*yield*/, ops.pop()];\r\n            case 13:\r\n                _b.sent();\r\n                return [3 /*break*/, 12];\r\n            case 14: return [2 /*return*/];\r\n        }\r\n    });\r\n}\n\nvar Token = /** @class */ (function () {\r\n    function Token(kind, input, begin, end, file) {\r\n        this.kind = kind;\r\n        this.input = input;\r\n        this.begin = begin;\r\n        this.end = end;\r\n        this.file = file;\r\n    }\r\n    Token.prototype.getText = function () {\r\n        return this.input.slice(this.begin, this.end);\r\n    };\r\n    Token.prototype.getPosition = function () {\r\n        var _a = __read([1, 1], 2), row = _a[0], col = _a[1];\r\n        for (var i = 0; i < this.begin; i++) {\r\n            if (this.input[i] === '\\n') {\r\n                row++;\r\n                col = 1;\r\n            }\r\n            else\r\n                col++;\r\n        }\r\n        return [row, col];\r\n    };\r\n    Token.prototype.size = function () {\r\n        return this.end - this.begin;\r\n    };\r\n    return Token;\r\n}());\n\nvar DelimitedToken = /** @class */ (function (_super) {\r\n    __extends(DelimitedToken, _super);\r\n    function DelimitedToken(kind, content, input, begin, end, trimLeft, trimRight, file) {\r\n        var _this = _super.call(this, kind, input, begin, end, file) || this;\r\n        _this.trimLeft = false;\r\n        _this.trimRight = false;\r\n        _this.content = _this.getText();\r\n        var tl = content[0] === '-';\r\n        var tr = last$1(content) === '-';\r\n        _this.content = content\r\n            .slice(tl ? 1 : 0, tr ? -1 : content.length)\r\n            .trim();\r\n        _this.trimLeft = tl || trimLeft;\r\n        _this.trimRight = tr || trimRight;\r\n        return _this;\r\n    }\r\n    return DelimitedToken;\r\n}(Token));\n\nfunction whiteSpaceCtrl(tokens, options) {\r\n    var inRaw = false;\r\n    for (var i = 0; i < tokens.length; i++) {\r\n        var token = tokens[i];\r\n        if (!isDelimitedToken(token))\r\n            continue;\r\n        if (!inRaw && token.trimLeft) {\r\n            trimLeft(tokens[i - 1], options.greedy);\r\n        }\r\n        if (isTagToken(token)) {\r\n            if (token.name === 'raw')\r\n                inRaw = true;\r\n            else if (token.name === 'endraw')\r\n                inRaw = false;\r\n        }\r\n        if (!inRaw && token.trimRight) {\r\n            trimRight(tokens[i + 1], options.greedy);\r\n        }\r\n    }\r\n}\r\nfunction trimLeft(token, greedy) {\r\n    if (!token || !isHTMLToken(token))\r\n        return;\r\n    var mask = greedy ? BLANK : INLINE_BLANK;\r\n    while (TYPES[token.input.charCodeAt(token.end - 1 - token.trimRight)] & mask)\r\n        token.trimRight++;\r\n}\r\nfunction trimRight(token, greedy) {\r\n    if (!token || !isHTMLToken(token))\r\n        return;\r\n    var mask = greedy ? BLANK : INLINE_BLANK;\r\n    while (TYPES[token.input.charCodeAt(token.begin + token.trimLeft)] & mask)\r\n        token.trimLeft++;\r\n    if (token.input.charAt(token.begin + token.trimLeft) === '\\n')\r\n        token.trimLeft++;\r\n}\n\nvar NumberToken = /** @class */ (function (_super) {\r\n    __extends(NumberToken, _super);\r\n    function NumberToken(whole, decimal) {\r\n        var _this = _super.call(this, TokenKind.Number, whole.input, whole.begin, decimal ? decimal.end : whole.end, whole.file) || this;\r\n        _this.whole = whole;\r\n        _this.decimal = decimal;\r\n        return _this;\r\n    }\r\n    return NumberToken;\r\n}(Token));\n\nvar IdentifierToken = /** @class */ (function (_super) {\r\n    __extends(IdentifierToken, _super);\r\n    function IdentifierToken(input, begin, end, file) {\r\n        var _this = _super.call(this, TokenKind.Word, input, begin, end, file) || this;\r\n        _this.input = input;\r\n        _this.begin = begin;\r\n        _this.end = end;\r\n        _this.file = file;\r\n        _this.content = _this.getText();\r\n        return _this;\r\n    }\r\n    IdentifierToken.prototype.isNumber = function (allowSign) {\r\n        if (allowSign === void 0) { allowSign = false; }\r\n        var begin = allowSign && TYPES[this.input.charCodeAt(this.begin)] & SIGN\r\n            ? this.begin + 1\r\n            : this.begin;\r\n        for (var i = begin; i < this.end; i++) {\r\n            if (!(TYPES[this.input.charCodeAt(i)] & NUMBER))\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n    return IdentifierToken;\r\n}(Token));\n\nvar LiteralToken = /** @class */ (function (_super) {\r\n    __extends(LiteralToken, _super);\r\n    function LiteralToken(input, begin, end, file) {\r\n        var _this = _super.call(this, TokenKind.Literal, input, begin, end, file) || this;\r\n        _this.input = input;\r\n        _this.begin = begin;\r\n        _this.end = end;\r\n        _this.file = file;\r\n        _this.literal = _this.getText();\r\n        return _this;\r\n    }\r\n    return LiteralToken;\r\n}(Token));\n\nvar precedence = {\r\n    '==': 1,\r\n    '!=': 1,\r\n    '>': 1,\r\n    '<': 1,\r\n    '>=': 1,\r\n    '<=': 1,\r\n    'contains': 1,\r\n    'and': 0,\r\n    'or': 0\r\n};\r\nvar OperatorToken = /** @class */ (function (_super) {\r\n    __extends(OperatorToken, _super);\r\n    function OperatorToken(input, begin, end, file) {\r\n        var _this = _super.call(this, TokenKind.Operator, input, begin, end, file) || this;\r\n        _this.input = input;\r\n        _this.begin = begin;\r\n        _this.end = end;\r\n        _this.file = file;\r\n        _this.operator = _this.getText();\r\n        return _this;\r\n    }\r\n    OperatorToken.prototype.getPrecedence = function () {\r\n        var key = this.getText();\r\n        return key in precedence ? precedence[key] : 1;\r\n    };\r\n    return OperatorToken;\r\n}(Token));\n\nvar PropertyAccessToken = /** @class */ (function (_super) {\r\n    __extends(PropertyAccessToken, _super);\r\n    function PropertyAccessToken(variable, props, end) {\r\n        var _this = _super.call(this, TokenKind.PropertyAccess, variable.input, variable.begin, end, variable.file) || this;\r\n        _this.variable = variable;\r\n        _this.props = props;\r\n        _this.propertyName = _this.variable instanceof IdentifierToken\r\n            ? _this.variable.getText()\r\n            : parseStringLiteral(_this.variable.getText());\r\n        return _this;\r\n    }\r\n    return PropertyAccessToken;\r\n}(Token));\n\nvar FilterToken = /** @class */ (function (_super) {\r\n    __extends(FilterToken, _super);\r\n    function FilterToken(name, args, input, begin, end, file) {\r\n        var _this = _super.call(this, TokenKind.Filter, input, begin, end, file) || this;\r\n        _this.name = name;\r\n        _this.args = args;\r\n        return _this;\r\n    }\r\n    return FilterToken;\r\n}(Token));\n\nvar HashToken = /** @class */ (function (_super) {\r\n    __extends(HashToken, _super);\r\n    function HashToken(input, begin, end, name, value, file) {\r\n        var _this = _super.call(this, TokenKind.Hash, input, begin, end, file) || this;\r\n        _this.input = input;\r\n        _this.begin = begin;\r\n        _this.end = end;\r\n        _this.name = name;\r\n        _this.value = value;\r\n        _this.file = file;\r\n        return _this;\r\n    }\r\n    return HashToken;\r\n}(Token));\n\nvar QuotedToken = /** @class */ (function (_super) {\r\n    __extends(QuotedToken, _super);\r\n    function QuotedToken(input, begin, end, file) {\r\n        var _this = _super.call(this, TokenKind.Quoted, input, begin, end, file) || this;\r\n        _this.input = input;\r\n        _this.begin = begin;\r\n        _this.end = end;\r\n        _this.file = file;\r\n        return _this;\r\n    }\r\n    return QuotedToken;\r\n}(Token));\n\nvar HTMLToken = /** @class */ (function (_super) {\r\n    __extends(HTMLToken, _super);\r\n    function HTMLToken(input, begin, end, file) {\r\n        var _this = _super.call(this, TokenKind.HTML, input, begin, end, file) || this;\r\n        _this.input = input;\r\n        _this.begin = begin;\r\n        _this.end = end;\r\n        _this.file = file;\r\n        _this.trimLeft = 0;\r\n        _this.trimRight = 0;\r\n        return _this;\r\n    }\r\n    HTMLToken.prototype.getContent = function () {\r\n        return this.input.slice(this.begin + this.trimLeft, this.end - this.trimRight);\r\n    };\r\n    return HTMLToken;\r\n}(Token));\n\nvar RangeToken = /** @class */ (function (_super) {\r\n    __extends(RangeToken, _super);\r\n    function RangeToken(input, begin, end, lhs, rhs, file) {\r\n        var _this = _super.call(this, TokenKind.Range, input, begin, end, file) || this;\r\n        _this.input = input;\r\n        _this.begin = begin;\r\n        _this.end = end;\r\n        _this.lhs = lhs;\r\n        _this.rhs = rhs;\r\n        _this.file = file;\r\n        return _this;\r\n    }\r\n    return RangeToken;\r\n}(Token));\n\nvar OutputToken = /** @class */ (function (_super) {\r\n    __extends(OutputToken, _super);\r\n    function OutputToken(input, begin, end, options, file) {\r\n        var _this = this;\r\n        var trimOutputLeft = options.trimOutputLeft, trimOutputRight = options.trimOutputRight, outputDelimiterLeft = options.outputDelimiterLeft, outputDelimiterRight = options.outputDelimiterRight;\r\n        var value = input.slice(begin + outputDelimiterLeft.length, end - outputDelimiterRight.length);\r\n        _this = _super.call(this, TokenKind.Output, value, input, begin, end, trimOutputLeft, trimOutputRight, file) || this;\r\n        return _this;\r\n    }\r\n    return OutputToken;\r\n}(DelimitedToken));\n\nfunction matchOperator(str, begin, trie, end) {\r\n    if (end === void 0) { end = str.length; }\r\n    var node = trie;\r\n    var i = begin;\r\n    var info;\r\n    while (node[str[i]] && i < end) {\r\n        node = node[str[i++]];\r\n        if (node['end'])\r\n            info = node;\r\n    }\r\n    if (!info)\r\n        return -1;\r\n    if (info['needBoundary'] && (TYPES[str.charCodeAt(i)] & IDENTIFIER))\r\n        return -1;\r\n    return i;\r\n}\n\nvar LiquidTagToken = /** @class */ (function (_super) {\r\n    __extends(LiquidTagToken, _super);\r\n    function LiquidTagToken(input, begin, end, options, file) {\r\n        var _this = this;\r\n        var value = input.slice(begin, end);\r\n        _this = _super.call(this, TokenKind.Tag, value, input, begin, end, false, false, file) || this;\r\n        if (!/\\S/.test(value)) {\r\n            // A line that contains only whitespace.\r\n            _this.name = '';\r\n            _this.args = '';\r\n        }\r\n        else {\r\n            var tokenizer = new Tokenizer(_this.content, options.operatorsTrie);\r\n            _this.name = tokenizer.readIdentifier().getText();\r\n            if (!_this.name)\r\n                throw new TokenizationError(\"illegal liquid tag syntax\", _this);\r\n            tokenizer.skipBlank();\r\n            _this.args = tokenizer.remaining();\r\n        }\r\n        return _this;\r\n    }\r\n    return LiquidTagToken;\r\n}(DelimitedToken));\n\nvar Tokenizer = /** @class */ (function () {\r\n    function Tokenizer(input, trie, file) {\r\n        if (file === void 0) { file = ''; }\r\n        this.input = input;\r\n        this.trie = trie;\r\n        this.file = file;\r\n        this.p = 0;\r\n        this.rawBeginAt = -1;\r\n        this.N = input.length;\r\n    }\r\n    Tokenizer.prototype.readExpression = function () {\r\n        return new Expression(this.readExpressionTokens());\r\n    };\r\n    Tokenizer.prototype.readExpressionTokens = function () {\r\n        var operand, operator, operand_1;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    operand = this.readValue();\r\n                    if (!operand)\r\n                        return [2 /*return*/];\r\n                    return [4 /*yield*/, operand];\r\n                case 1:\r\n                    _a.sent();\r\n                    _a.label = 2;\r\n                case 2:\r\n                    if (!(this.p < this.N)) return [3 /*break*/, 5];\r\n                    operator = this.readOperator();\r\n                    if (!operator)\r\n                        return [2 /*return*/];\r\n                    operand_1 = this.readValue();\r\n                    if (!operand_1)\r\n                        return [2 /*return*/];\r\n                    return [4 /*yield*/, operator];\r\n                case 3:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, operand_1];\r\n                case 4:\r\n                    _a.sent();\r\n                    return [3 /*break*/, 2];\r\n                case 5: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    Tokenizer.prototype.readOperator = function () {\r\n        this.skipBlank();\r\n        var end = matchOperator(this.input, this.p, this.trie);\r\n        if (end === -1)\r\n            return;\r\n        return new OperatorToken(this.input, this.p, (this.p = end), this.file);\r\n    };\r\n    Tokenizer.prototype.readFilters = function () {\r\n        var filters = [];\r\n        while (true) {\r\n            var filter = this.readFilter();\r\n            if (!filter)\r\n                return filters;\r\n            filters.push(filter);\r\n        }\r\n    };\r\n    Tokenizer.prototype.readFilter = function () {\r\n        var _this = this;\r\n        this.skipBlank();\r\n        if (this.end())\r\n            return null;\r\n        assert(this.peek() === '|', function () { return \"unexpected token at \".concat(_this.snapshot()); });\r\n        this.p++;\r\n        var begin = this.p;\r\n        var name = this.readIdentifier();\r\n        if (!name.size())\r\n            return null;\r\n        var args = [];\r\n        this.skipBlank();\r\n        if (this.peek() === ':') {\r\n            do {\r\n                ++this.p;\r\n                var arg = this.readFilterArg();\r\n                arg && args.push(arg);\r\n                this.skipBlank();\r\n                assert(this.end() || this.peek() === ',' || this.peek() === '|', function () { return \"unexpected character \".concat(_this.snapshot()); });\r\n            } while (this.peek() === ',');\r\n        }\r\n        return new FilterToken(name.getText(), args, this.input, begin, this.p, this.file);\r\n    };\r\n    Tokenizer.prototype.readFilterArg = function () {\r\n        var key = this.readValue();\r\n        if (!key)\r\n            return;\r\n        this.skipBlank();\r\n        if (this.peek() !== ':')\r\n            return key;\r\n        ++this.p;\r\n        var value = this.readValue();\r\n        return [key.getText(), value];\r\n    };\r\n    Tokenizer.prototype.readTopLevelTokens = function (options) {\r\n        if (options === void 0) { options = defaultOptions; }\r\n        var tokens = [];\r\n        while (this.p < this.N) {\r\n            var token = this.readTopLevelToken(options);\r\n            tokens.push(token);\r\n        }\r\n        whiteSpaceCtrl(tokens, options);\r\n        return tokens;\r\n    };\r\n    Tokenizer.prototype.readTopLevelToken = function (options) {\r\n        var tagDelimiterLeft = options.tagDelimiterLeft, outputDelimiterLeft = options.outputDelimiterLeft;\r\n        if (this.rawBeginAt > -1)\r\n            return this.readEndrawOrRawContent(options);\r\n        if (this.match(tagDelimiterLeft))\r\n            return this.readTagToken(options);\r\n        if (this.match(outputDelimiterLeft))\r\n            return this.readOutputToken(options);\r\n        return this.readHTMLToken([tagDelimiterLeft, outputDelimiterLeft]);\r\n    };\r\n    Tokenizer.prototype.readHTMLToken = function (stopStrings) {\r\n        var _this = this;\r\n        var begin = this.p;\r\n        while (this.p < this.N) {\r\n            if (stopStrings.some(function (str) { return _this.match(str); }))\r\n                break;\r\n            ++this.p;\r\n        }\r\n        return new HTMLToken(this.input, begin, this.p, this.file);\r\n    };\r\n    Tokenizer.prototype.readTagToken = function (options) {\r\n        if (options === void 0) { options = defaultOptions; }\r\n        var _a = this, file = _a.file, input = _a.input;\r\n        var begin = this.p;\r\n        if (this.readToDelimiter(options.tagDelimiterRight) === -1) {\r\n            throw this.mkError(\"tag \".concat(this.snapshot(begin), \" not closed\"), begin);\r\n        }\r\n        var token = new TagToken(input, begin, this.p, options, file);\r\n        if (token.name === 'raw')\r\n            this.rawBeginAt = begin;\r\n        return token;\r\n    };\r\n    Tokenizer.prototype.readToDelimiter = function (delimiter) {\r\n        while (this.p < this.N) {\r\n            if ((this.peekType() & QUOTE)) {\r\n                this.readQuoted();\r\n                continue;\r\n            }\r\n            ++this.p;\r\n            if (this.rmatch(delimiter))\r\n                return this.p;\r\n        }\r\n        return -1;\r\n    };\r\n    Tokenizer.prototype.readOutputToken = function (options) {\r\n        if (options === void 0) { options = defaultOptions; }\r\n        var _a = this, file = _a.file, input = _a.input;\r\n        var outputDelimiterRight = options.outputDelimiterRight;\r\n        var begin = this.p;\r\n        if (this.readToDelimiter(outputDelimiterRight) === -1) {\r\n            throw this.mkError(\"output \".concat(this.snapshot(begin), \" not closed\"), begin);\r\n        }\r\n        return new OutputToken(input, begin, this.p, options, file);\r\n    };\r\n    Tokenizer.prototype.readEndrawOrRawContent = function (options) {\r\n        var tagDelimiterLeft = options.tagDelimiterLeft, tagDelimiterRight = options.tagDelimiterRight;\r\n        var begin = this.p;\r\n        var leftPos = this.readTo(tagDelimiterLeft) - tagDelimiterLeft.length;\r\n        while (this.p < this.N) {\r\n            if (this.readIdentifier().getText() !== 'endraw') {\r\n                leftPos = this.readTo(tagDelimiterLeft) - tagDelimiterLeft.length;\r\n                continue;\r\n            }\r\n            while (this.p <= this.N) {\r\n                if (this.rmatch(tagDelimiterRight)) {\r\n                    var end = this.p;\r\n                    if (begin === leftPos) {\r\n                        this.rawBeginAt = -1;\r\n                        return new TagToken(this.input, begin, end, options, this.file);\r\n                    }\r\n                    else {\r\n                        this.p = leftPos;\r\n                        return new HTMLToken(this.input, begin, leftPos, this.file);\r\n                    }\r\n                }\r\n                if (this.rmatch(tagDelimiterLeft))\r\n                    break;\r\n                this.p++;\r\n            }\r\n        }\r\n        throw this.mkError(\"raw \".concat(this.snapshot(this.rawBeginAt), \" not closed\"), begin);\r\n    };\r\n    Tokenizer.prototype.readLiquidTagTokens = function (options) {\r\n        if (options === void 0) { options = defaultOptions; }\r\n        var tokens = [];\r\n        while (this.p < this.N) {\r\n            var token = this.readLiquidTagToken(options);\r\n            if (token.name)\r\n                tokens.push(token);\r\n        }\r\n        return tokens;\r\n    };\r\n    Tokenizer.prototype.readLiquidTagToken = function (options) {\r\n        var _a = this, file = _a.file, input = _a.input;\r\n        var begin = this.p;\r\n        var end = this.N;\r\n        if (this.readToDelimiter('\\n') !== -1)\r\n            end = this.p;\r\n        var token = new LiquidTagToken(input, begin, end, options, file);\r\n        return token;\r\n    };\r\n    Tokenizer.prototype.mkError = function (msg, begin) {\r\n        return new TokenizationError(msg, new IdentifierToken(this.input, begin, this.N, this.file));\r\n    };\r\n    Tokenizer.prototype.snapshot = function (begin) {\r\n        if (begin === void 0) { begin = this.p; }\r\n        return JSON.stringify(ellipsis(this.input.slice(begin), 16));\r\n    };\r\n    /**\r\n     * @deprecated\r\n     */\r\n    Tokenizer.prototype.readWord = function () {\r\n        console.warn('Tokenizer#readWord() will be removed, use #readIdentifier instead');\r\n        return this.readIdentifier();\r\n    };\r\n    Tokenizer.prototype.readIdentifier = function () {\r\n        this.skipBlank();\r\n        var begin = this.p;\r\n        while (this.peekType() & IDENTIFIER)\r\n            ++this.p;\r\n        return new IdentifierToken(this.input, begin, this.p, this.file);\r\n    };\r\n    Tokenizer.prototype.readHashes = function (jekyllStyle) {\r\n        var hashes = [];\r\n        while (true) {\r\n            var hash = this.readHash(jekyllStyle);\r\n            if (!hash)\r\n                return hashes;\r\n            hashes.push(hash);\r\n        }\r\n    };\r\n    Tokenizer.prototype.readHash = function (jekyllStyle) {\r\n        this.skipBlank();\r\n        if (this.peek() === ',')\r\n            ++this.p;\r\n        var begin = this.p;\r\n        var name = this.readIdentifier();\r\n        if (!name.size())\r\n            return;\r\n        var value;\r\n        this.skipBlank();\r\n        var sep = jekyllStyle ? '=' : ':';\r\n        if (this.peek() === sep) {\r\n            ++this.p;\r\n            value = this.readValue();\r\n        }\r\n        return new HashToken(this.input, begin, this.p, name, value, this.file);\r\n    };\r\n    Tokenizer.prototype.remaining = function () {\r\n        return this.input.slice(this.p);\r\n    };\r\n    Tokenizer.prototype.advance = function (i) {\r\n        if (i === void 0) { i = 1; }\r\n        this.p += i;\r\n    };\r\n    Tokenizer.prototype.end = function () {\r\n        return this.p >= this.N;\r\n    };\r\n    Tokenizer.prototype.readTo = function (end) {\r\n        while (this.p < this.N) {\r\n            ++this.p;\r\n            if (this.rmatch(end))\r\n                return this.p;\r\n        }\r\n        return -1;\r\n    };\r\n    Tokenizer.prototype.readValue = function () {\r\n        var value = this.readQuoted() || this.readRange();\r\n        if (value)\r\n            return value;\r\n        if (this.peek() === '[') {\r\n            this.p++;\r\n            var prop = this.readQuoted();\r\n            if (!prop)\r\n                return;\r\n            if (this.peek() !== ']')\r\n                return;\r\n            this.p++;\r\n            return new PropertyAccessToken(prop, [], this.p);\r\n        }\r\n        var variable = this.readIdentifier();\r\n        if (!variable.size())\r\n            return;\r\n        var isNumber = variable.isNumber(true);\r\n        var props = [];\r\n        while (true) {\r\n            if (this.peek() === '[') {\r\n                isNumber = false;\r\n                this.p++;\r\n                var prop = this.readValue() || new IdentifierToken(this.input, this.p, this.p, this.file);\r\n                this.readTo(']');\r\n                props.push(prop);\r\n            }\r\n            else if (this.peek() === '.' && this.peek(1) !== '.') { // skip range syntax\r\n                this.p++;\r\n                var prop = this.readIdentifier();\r\n                if (!prop.size())\r\n                    break;\r\n                if (!prop.isNumber())\r\n                    isNumber = false;\r\n                props.push(prop);\r\n            }\r\n            else\r\n                break;\r\n        }\r\n        if (!props.length && literalValues.hasOwnProperty(variable.content)) {\r\n            return new LiteralToken(this.input, variable.begin, variable.end, this.file);\r\n        }\r\n        if (isNumber)\r\n            return new NumberToken(variable, props[0]);\r\n        return new PropertyAccessToken(variable, props, this.p);\r\n    };\r\n    Tokenizer.prototype.readRange = function () {\r\n        this.skipBlank();\r\n        var begin = this.p;\r\n        if (this.peek() !== '(')\r\n            return;\r\n        ++this.p;\r\n        var lhs = this.readValueOrThrow();\r\n        this.p += 2;\r\n        var rhs = this.readValueOrThrow();\r\n        ++this.p;\r\n        return new RangeToken(this.input, begin, this.p, lhs, rhs, this.file);\r\n    };\r\n    Tokenizer.prototype.readValueOrThrow = function () {\r\n        var _this = this;\r\n        var value = this.readValue();\r\n        assert(value, function () { return \"unexpected token \".concat(_this.snapshot(), \", value expected\"); });\r\n        return value;\r\n    };\r\n    Tokenizer.prototype.readQuoted = function () {\r\n        this.skipBlank();\r\n        var begin = this.p;\r\n        if (!(this.peekType() & QUOTE))\r\n            return;\r\n        ++this.p;\r\n        var escaped = false;\r\n        while (this.p < this.N) {\r\n            ++this.p;\r\n            if (this.input[this.p - 1] === this.input[begin] && !escaped)\r\n                break;\r\n            if (escaped)\r\n                escaped = false;\r\n            else if (this.input[this.p - 1] === '\\\\')\r\n                escaped = true;\r\n        }\r\n        return new QuotedToken(this.input, begin, this.p, this.file);\r\n    };\r\n    Tokenizer.prototype.readFileNameTemplate = function (options) {\r\n        var outputDelimiterLeft, htmlStopStrings, htmlStopStringSet;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    outputDelimiterLeft = options.outputDelimiterLeft;\r\n                    htmlStopStrings = [',', ' ', outputDelimiterLeft];\r\n                    htmlStopStringSet = new Set(htmlStopStrings);\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!(this.p < this.N && !htmlStopStringSet.has(this.peek()))) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, this.match(outputDelimiterLeft)\r\n                            ? this.readOutputToken(options)\r\n                            : this.readHTMLToken(htmlStopStrings)];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [3 /*break*/, 1];\r\n                case 3: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    Tokenizer.prototype.match = function (word) {\r\n        for (var i = 0; i < word.length; i++) {\r\n            if (word[i] !== this.input[this.p + i])\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n    Tokenizer.prototype.rmatch = function (pattern) {\r\n        for (var i = 0; i < pattern.length; i++) {\r\n            if (pattern[pattern.length - 1 - i] !== this.input[this.p - 1 - i])\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n    Tokenizer.prototype.peekType = function (n) {\r\n        if (n === void 0) { n = 0; }\r\n        return TYPES[this.input.charCodeAt(this.p + n)];\r\n    };\r\n    Tokenizer.prototype.peek = function (n) {\r\n        if (n === void 0) { n = 0; }\r\n        return this.input[this.p + n];\r\n    };\r\n    Tokenizer.prototype.skipBlank = function () {\r\n        while (this.peekType() & BLANK)\r\n            ++this.p;\r\n    };\r\n    return Tokenizer;\r\n}());\n\nvar TagToken = /** @class */ (function (_super) {\r\n    __extends(TagToken, _super);\r\n    function TagToken(input, begin, end, options, file) {\r\n        var _this = this;\r\n        var trimTagLeft = options.trimTagLeft, trimTagRight = options.trimTagRight, tagDelimiterLeft = options.tagDelimiterLeft, tagDelimiterRight = options.tagDelimiterRight;\r\n        var value = input.slice(begin + tagDelimiterLeft.length, end - tagDelimiterRight.length);\r\n        _this = _super.call(this, TokenKind.Tag, value, input, begin, end, trimTagLeft, trimTagRight, file) || this;\r\n        var tokenizer = new Tokenizer(_this.content, options.operatorsTrie);\r\n        _this.name = tokenizer.readIdentifier().getText();\r\n        if (!_this.name)\r\n            throw new TokenizationError(\"illegal tag syntax\", _this);\r\n        tokenizer.skipBlank();\r\n        _this.args = tokenizer.remaining();\r\n        return _this;\r\n    }\r\n    return TagToken;\r\n}(DelimitedToken));\n\n/**\r\n * Key-Value Pairs Representing Tag Arguments\r\n * Example:\r\n *    For the markup `, foo:'bar', coo:2 reversed %}`,\r\n *    hash['foo'] === 'bar'\r\n *    hash['coo'] === 2\r\n *    hash['reversed'] === undefined\r\n */\r\nvar Hash = /** @class */ (function () {\r\n    function Hash(markup, jekyllStyle) {\r\n        var e_1, _a;\r\n        this.hash = {};\r\n        var tokenizer = new Tokenizer(markup, {});\r\n        try {\r\n            for (var _b = __values(tokenizer.readHashes(jekyllStyle)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var hash = _c.value;\r\n                this.hash[hash.name.content] = hash.value;\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    }\r\n    Hash.prototype.render = function (ctx) {\r\n        var hash, _a, _b, key, _c, _d, _e, e_2_1;\r\n        var e_2, _f;\r\n        return __generator(this, function (_g) {\r\n            switch (_g.label) {\r\n                case 0:\r\n                    hash = {};\r\n                    _g.label = 1;\r\n                case 1:\r\n                    _g.trys.push([1, 8, 9, 10]);\r\n                    _a = __values(Object.keys(this.hash)), _b = _a.next();\r\n                    _g.label = 2;\r\n                case 2:\r\n                    if (!!_b.done) return [3 /*break*/, 7];\r\n                    key = _b.value;\r\n                    _c = hash;\r\n                    _d = key;\r\n                    if (!(this.hash[key] === undefined)) return [3 /*break*/, 3];\r\n                    _e = true;\r\n                    return [3 /*break*/, 5];\r\n                case 3: return [4 /*yield*/, evalToken(this.hash[key], ctx)];\r\n                case 4:\r\n                    _e = _g.sent();\r\n                    _g.label = 5;\r\n                case 5:\r\n                    _c[_d] = _e;\r\n                    _g.label = 6;\r\n                case 6:\r\n                    _b = _a.next();\r\n                    return [3 /*break*/, 2];\r\n                case 7: return [3 /*break*/, 10];\r\n                case 8:\r\n                    e_2_1 = _g.sent();\r\n                    e_2 = { error: e_2_1 };\r\n                    return [3 /*break*/, 10];\r\n                case 9:\r\n                    try {\r\n                        if (_b && !_b.done && (_f = _a.return)) _f.call(_a);\r\n                    }\r\n                    finally { if (e_2) throw e_2.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 10: return [2 /*return*/, hash];\r\n            }\r\n        });\r\n    };\r\n    return Hash;\r\n}());\n\nfunction isKeyValuePair(arr) {\r\n    return isArray(arr);\r\n}\n\nvar Filter = /** @class */ (function () {\r\n    function Filter(name, impl, args, liquid) {\r\n        this.name = name;\r\n        this.impl = impl || identify;\r\n        this.args = args;\r\n        this.liquid = liquid;\r\n    }\r\n    Filter.prototype.render = function (value, context) {\r\n        var e_1, _a;\r\n        var argv = [];\r\n        try {\r\n            for (var _b = __values(this.args), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var arg = _c.value;\r\n                if (isKeyValuePair(arg))\r\n                    argv.push([arg[0], evalToken(arg[1], context)]);\r\n                else\r\n                    argv.push(evalToken(arg, context));\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return this.impl.apply({ context: context, liquid: this.liquid }, __spreadArray([value], __read(argv), false));\r\n    };\r\n    return Filter;\r\n}());\n\nvar Value = /** @class */ (function () {\r\n    /**\r\n     * @param str the value to be valuated, eg.: \"foobar\" | truncate: 3\r\n     */\r\n    function Value(str, liquid) {\r\n        this.filters = [];\r\n        var tokenizer = new Tokenizer(str, liquid.options.operatorsTrie);\r\n        this.initial = tokenizer.readExpression();\r\n        this.filters = tokenizer.readFilters().map(function (_a) {\r\n            var name = _a.name, args = _a.args;\r\n            return new Filter(name, liquid.filters.get(name), args, liquid);\r\n        });\r\n    }\r\n    Value.prototype.value = function (ctx, lenient) {\r\n        var val, _a, _b, filter, e_1_1;\r\n        var e_1, _c;\r\n        return __generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0:\r\n                    lenient = lenient || (ctx.opts.lenientIf && this.filters.length > 0 && this.filters[0].name === 'default');\r\n                    return [4 /*yield*/, this.initial.evaluate(ctx, lenient)];\r\n                case 1:\r\n                    val = _d.sent();\r\n                    _d.label = 2;\r\n                case 2:\r\n                    _d.trys.push([2, 7, 8, 9]);\r\n                    _a = __values(this.filters), _b = _a.next();\r\n                    _d.label = 3;\r\n                case 3:\r\n                    if (!!_b.done) return [3 /*break*/, 6];\r\n                    filter = _b.value;\r\n                    return [4 /*yield*/, filter.render(val, ctx)];\r\n                case 4:\r\n                    val = _d.sent();\r\n                    _d.label = 5;\r\n                case 5:\r\n                    _b = _a.next();\r\n                    return [3 /*break*/, 3];\r\n                case 6: return [3 /*break*/, 9];\r\n                case 7:\r\n                    e_1_1 = _d.sent();\r\n                    e_1 = { error: e_1_1 };\r\n                    return [3 /*break*/, 9];\r\n                case 8:\r\n                    try {\r\n                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\r\n                    }\r\n                    finally { if (e_1) throw e_1.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 9: return [2 /*return*/, val];\r\n            }\r\n        });\r\n    };\r\n    return Value;\r\n}());\n\n// one minute in milliseconds\r\nvar OneMinute = 60000;\r\nvar hostTimezoneOffset = new Date().getTimezoneOffset();\r\nvar ISO8601_TIMEZONE_PATTERN = /([zZ]|([+-])(\\d{2}):(\\d{2}))$/;\r\n/**\r\n * A date implementation with timezone info, just like Ruby date\r\n *\r\n * Implementation:\r\n * - create a Date offset by it's timezone difference, avoiding overriding a bunch of methods\r\n * - rewrite getTimezoneOffset() to trick strftime\r\n */\r\nvar TimezoneDate = /** @class */ (function () {\r\n    function TimezoneDate(init, timezoneOffset) {\r\n        if (init instanceof TimezoneDate) {\r\n            this.date = init.date;\r\n            timezoneOffset = init.timezoneOffset;\r\n        }\r\n        else {\r\n            var diff = (hostTimezoneOffset - timezoneOffset) * OneMinute;\r\n            var time = new Date(init).getTime() + diff;\r\n            this.date = new Date(time);\r\n        }\r\n        this.timezoneOffset = timezoneOffset;\r\n    }\r\n    TimezoneDate.prototype.getTime = function () {\r\n        return this.date.getTime();\r\n    };\r\n    TimezoneDate.prototype.getMilliseconds = function () {\r\n        return this.date.getMilliseconds();\r\n    };\r\n    TimezoneDate.prototype.getSeconds = function () {\r\n        return this.date.getSeconds();\r\n    };\r\n    TimezoneDate.prototype.getMinutes = function () {\r\n        return this.date.getMinutes();\r\n    };\r\n    TimezoneDate.prototype.getHours = function () {\r\n        return this.date.getHours();\r\n    };\r\n    TimezoneDate.prototype.getDay = function () {\r\n        return this.date.getDay();\r\n    };\r\n    TimezoneDate.prototype.getDate = function () {\r\n        return this.date.getDate();\r\n    };\r\n    TimezoneDate.prototype.getMonth = function () {\r\n        return this.date.getMonth();\r\n    };\r\n    TimezoneDate.prototype.getFullYear = function () {\r\n        return this.date.getFullYear();\r\n    };\r\n    TimezoneDate.prototype.toLocaleTimeString = function (locale) {\r\n        return this.date.toLocaleTimeString(locale);\r\n    };\r\n    TimezoneDate.prototype.toLocaleDateString = function (locale) {\r\n        return this.date.toLocaleDateString(locale);\r\n    };\r\n    TimezoneDate.prototype.getTimezoneOffset = function () {\r\n        return this.timezoneOffset;\r\n    };\r\n    /**\r\n     * Create a Date object fixed to it's declared Timezone. Both\r\n     * - 2021-08-06T02:29:00.000Z and\r\n     * - 2021-08-06T02:29:00.000+08:00\r\n     * will always be displayed as\r\n     * - 2021-08-06 02:29:00\r\n     * regardless timezoneOffset in JavaScript realm\r\n     *\r\n     * The implementation hack:\r\n     * Instead of calling `.getMonth()`/`.getUTCMonth()` respect to `preserveTimezones`,\r\n     * we create a different Date to trick strftime, it's both simpler and more performant.\r\n     * Given that a template is expected to be parsed fewer times than rendered.\r\n     */\r\n    TimezoneDate.createDateFixedToTimezone = function (dateString) {\r\n        var m = dateString.match(ISO8601_TIMEZONE_PATTERN);\r\n        // representing a UTC timestamp\r\n        if (m && m[1] === 'Z') {\r\n            return new TimezoneDate(+new Date(dateString), 0);\r\n        }\r\n        // has a timezone specified\r\n        if (m && m[2] && m[3] && m[4]) {\r\n            var _a = __read(m, 5), sign = _a[2], hours = _a[3], minutes = _a[4];\r\n            var delta = (sign === '+' ? -1 : 1) * (parseInt(hours, 10) * 60 + parseInt(minutes, 10));\r\n            return new TimezoneDate(+new Date(dateString), delta);\r\n        }\r\n        return new Date(dateString);\r\n    };\r\n    return TimezoneDate;\r\n}());\n\nvar escapeMap = {\r\n    '&': '&amp;',\r\n    '<': '&lt;',\r\n    '>': '&gt;',\r\n    '\"': '&#34;',\r\n    \"'\": '&#39;'\r\n};\r\nvar unescapeMap = {\r\n    '&amp;': '&',\r\n    '&lt;': '<',\r\n    '&gt;': '>',\r\n    '&#34;': '\"',\r\n    '&#39;': \"'\"\r\n};\r\nfunction escape(str) {\r\n    return stringify(str).replace(/&|<|>|\"|'/g, function (m) { return escapeMap[m]; });\r\n}\r\nfunction unescape(str) {\r\n    return stringify(str).replace(/&(amp|lt|gt|#34|#39);/g, function (m) { return unescapeMap[m]; });\r\n}\r\nfunction escapeOnce(str) {\r\n    return escape(unescape(stringify(str)));\r\n}\r\nfunction newlineToBr(v) {\r\n    return stringify(v).replace(/\\n/g, '<br />\\n');\r\n}\r\nfunction stripHtml(v) {\r\n    return stringify(v).replace(/<script.*?<\\/script>|<!--.*?-->|<style.*?<\\/style>|<.*?>/g, '');\r\n}\n\nvar abs = argumentsToValue(Math.abs);\r\nvar atLeast = argumentsToValue(Math.max);\r\nvar atMost = argumentsToValue(Math.min);\r\nvar ceil = argumentsToValue(Math.ceil);\r\nvar dividedBy = argumentsToValue(function (v, arg) { return v / arg; });\r\nvar floor = argumentsToValue(Math.floor);\r\nvar minus = argumentsToValue(function (v, arg) { return v - arg; });\r\nvar modulo = argumentsToValue(function (v, arg) { return v % arg; });\r\nvar times = argumentsToValue(function (v, arg) { return v * arg; });\r\nfunction round(v, arg) {\r\n    if (arg === void 0) { arg = 0; }\r\n    v = toValue$1(v);\r\n    arg = toValue$1(arg);\r\n    var amp = Math.pow(10, arg);\r\n    return Math.round(v * amp) / amp;\r\n}\r\nfunction plus(v, arg) {\r\n    v = toValue$1(v);\r\n    arg = toValue$1(arg);\r\n    return Number(v) + Number(arg);\r\n}\n\nvar urlDecode = function (x) { return stringify(x).split('+').map(decodeURIComponent).join(' '); };\r\nvar urlEncode = function (x) { return stringify(x).split(' ').map(encodeURIComponent).join('+'); };\n\nfunction toEnumerable(val) {\r\n    if (isArray(val))\r\n        return val;\r\n    if (isString(val) && val.length > 0)\r\n        return [val];\r\n    if (isObject(val))\r\n        return Object.keys(val).map(function (key) { return [key, val[key]]; });\r\n    return [];\r\n}\r\nfunction toArray(val) {\r\n    if (isNil(val))\r\n        return [];\r\n    if (isArray(val))\r\n        return val;\r\n    return [val];\r\n}\n\nvar join = argumentsToValue(function (v, arg) { return toArray(v).join(arg === undefined ? ' ' : arg); });\r\nvar last = argumentsToValue(function (v) { return isArray(v) ? last$1(v) : ''; });\r\nvar first = argumentsToValue(function (v) { return isArray(v) ? v[0] : ''; });\r\nvar reverse = argumentsToValue(function (v) { return __spreadArray([], __read(toArray(v)), false).reverse(); });\r\nfunction sort(arr, property) {\r\n    var _this = this;\r\n    arr = toValue$1(arr);\r\n    var getValue = function (obj) { return property ? _this.context.getFromScope(obj, stringify(property).split('.')) : obj; };\r\n    return __spreadArray([], __read(toArray(arr)), false).sort(function (lhs, rhs) {\r\n        lhs = getValue(lhs);\r\n        rhs = getValue(rhs);\r\n        return lhs < rhs ? -1 : (lhs > rhs ? 1 : 0);\r\n    });\r\n}\r\nfunction sortNatural(input, property) {\r\n    input = toValue$1(input);\r\n    var propertyString = stringify(property);\r\n    var compare = property === undefined\r\n        ? caseInsensitiveCompare\r\n        : function (lhs, rhs) { return caseInsensitiveCompare(lhs[propertyString], rhs[propertyString]); };\r\n    return __spreadArray([], __read(toArray(input)), false).sort(compare);\r\n}\r\nvar size = function (v) { return (v && v.length) || 0; };\r\nfunction map(arr, property) {\r\n    var _this = this;\r\n    arr = toValue$1(arr);\r\n    return toArray(arr).map(function (obj) { return _this.context.getFromScope(obj, stringify(property).split('.')); });\r\n}\r\nfunction compact(arr) {\r\n    arr = toValue$1(arr);\r\n    return toArray(arr).filter(function (x) { return !isNil(toValue$1(x)); });\r\n}\r\nfunction concat(v, arg) {\r\n    if (arg === void 0) { arg = []; }\r\n    v = toValue$1(v);\r\n    arg = toArray(arg).map(function (v) { return toValue$1(v); });\r\n    return toArray(v).concat(arg);\r\n}\r\nfunction slice(v, begin, length) {\r\n    if (length === void 0) { length = 1; }\r\n    v = toValue$1(v);\r\n    if (isNil(v))\r\n        return [];\r\n    if (!isArray(v))\r\n        v = stringify(v);\r\n    begin = begin < 0 ? v.length + begin : begin;\r\n    return v.slice(begin, begin + length);\r\n}\r\nfunction where(arr, property, expected) {\r\n    var _this = this;\r\n    arr = toValue$1(arr);\r\n    return toArray(arr).filter(function (obj) {\r\n        var value = _this.context.getFromScope(obj, stringify(property).split('.'));\r\n        if (expected === undefined)\r\n            return isTruthy(value, _this.context);\r\n        if (isComparable(expected))\r\n            return expected.equals(value);\r\n        return value === expected;\r\n    });\r\n}\r\nfunction uniq(arr) {\r\n    arr = toValue$1(arr);\r\n    var u = {};\r\n    return (arr || []).filter(function (val) {\r\n        if (hasOwnProperty.call(u, String(val)))\r\n            return false;\r\n        u[String(val)] = true;\r\n        return true;\r\n    });\r\n}\n\nvar rFormat = /%([-_0^#:]+)?(\\d+)?([EO])?(.)/;\r\nvar monthNames = [\r\n    'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August',\r\n    'September', 'October', 'November', 'December'\r\n];\r\nvar dayNames = [\r\n    'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'\r\n];\r\nvar monthNamesShort = monthNames.map(abbr);\r\nvar dayNamesShort = dayNames.map(abbr);\r\nvar suffixes = {\r\n    1: 'st',\r\n    2: 'nd',\r\n    3: 'rd',\r\n    'default': 'th'\r\n};\r\nfunction abbr(str) {\r\n    return str.slice(0, 3);\r\n}\r\n// prototype extensions\r\nfunction daysInMonth(d) {\r\n    var feb = isLeapYear(d) ? 29 : 28;\r\n    return [31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n}\r\nfunction getDayOfYear(d) {\r\n    var num = 0;\r\n    for (var i = 0; i < d.getMonth(); ++i) {\r\n        num += daysInMonth(d)[i];\r\n    }\r\n    return num + d.getDate();\r\n}\r\nfunction getWeekOfYear(d, startDay) {\r\n    // Skip to startDay of this week\r\n    var now = getDayOfYear(d) + (startDay - d.getDay());\r\n    // Find the first startDay of the year\r\n    var jan1 = new Date(d.getFullYear(), 0, 1);\r\n    var then = (7 - jan1.getDay() + startDay);\r\n    return String(Math.floor((now - then) / 7) + 1);\r\n}\r\nfunction isLeapYear(d) {\r\n    var year = d.getFullYear();\r\n    return !!((year & 3) === 0 && (year % 100 || (year % 400 === 0 && year)));\r\n}\r\nfunction getSuffix(d) {\r\n    var str = d.getDate().toString();\r\n    var index = parseInt(str.slice(-1));\r\n    return suffixes[index] || suffixes['default'];\r\n}\r\nfunction century(d) {\r\n    return parseInt(d.getFullYear().toString().substring(0, 2), 10);\r\n}\r\n// default to 0\r\nvar padWidths = {\r\n    d: 2,\r\n    e: 2,\r\n    H: 2,\r\n    I: 2,\r\n    j: 3,\r\n    k: 2,\r\n    l: 2,\r\n    L: 3,\r\n    m: 2,\r\n    M: 2,\r\n    S: 2,\r\n    U: 2,\r\n    W: 2\r\n};\r\n// default to '0'\r\nvar padChars = {\r\n    a: ' ',\r\n    A: ' ',\r\n    b: ' ',\r\n    B: ' ',\r\n    c: ' ',\r\n    e: ' ',\r\n    k: ' ',\r\n    l: ' ',\r\n    p: ' ',\r\n    P: ' '\r\n};\r\nvar formatCodes = {\r\n    a: function (d) { return dayNamesShort[d.getDay()]; },\r\n    A: function (d) { return dayNames[d.getDay()]; },\r\n    b: function (d) { return monthNamesShort[d.getMonth()]; },\r\n    B: function (d) { return monthNames[d.getMonth()]; },\r\n    c: function (d) { return d.toLocaleString(); },\r\n    C: function (d) { return century(d); },\r\n    d: function (d) { return d.getDate(); },\r\n    e: function (d) { return d.getDate(); },\r\n    H: function (d) { return d.getHours(); },\r\n    I: function (d) { return String(d.getHours() % 12 || 12); },\r\n    j: function (d) { return getDayOfYear(d); },\r\n    k: function (d) { return d.getHours(); },\r\n    l: function (d) { return String(d.getHours() % 12 || 12); },\r\n    L: function (d) { return d.getMilliseconds(); },\r\n    m: function (d) { return d.getMonth() + 1; },\r\n    M: function (d) { return d.getMinutes(); },\r\n    N: function (d, opts) {\r\n        var width = Number(opts.width) || 9;\r\n        var str = String(d.getMilliseconds()).substr(0, width);\r\n        return padEnd(str, width, '0');\r\n    },\r\n    p: function (d) { return (d.getHours() < 12 ? 'AM' : 'PM'); },\r\n    P: function (d) { return (d.getHours() < 12 ? 'am' : 'pm'); },\r\n    q: function (d) { return getSuffix(d); },\r\n    s: function (d) { return Math.round(d.getTime() / 1000); },\r\n    S: function (d) { return d.getSeconds(); },\r\n    u: function (d) { return d.getDay() || 7; },\r\n    U: function (d) { return getWeekOfYear(d, 0); },\r\n    w: function (d) { return d.getDay(); },\r\n    W: function (d) { return getWeekOfYear(d, 1); },\r\n    x: function (d) { return d.toLocaleDateString(); },\r\n    X: function (d) { return d.toLocaleTimeString(); },\r\n    y: function (d) { return d.getFullYear().toString().substring(2, 4); },\r\n    Y: function (d) { return d.getFullYear(); },\r\n    z: function (d, opts) {\r\n        var nOffset = Math.abs(d.getTimezoneOffset());\r\n        var h = Math.floor(nOffset / 60);\r\n        var m = nOffset % 60;\r\n        return (d.getTimezoneOffset() > 0 ? '-' : '+') +\r\n            padStart(h, 2, '0') +\r\n            (opts.flags[':'] ? ':' : '') +\r\n            padStart(m, 2, '0');\r\n    },\r\n    't': function () { return '\\t'; },\r\n    'n': function () { return '\\n'; },\r\n    '%': function () { return '%'; }\r\n};\r\nformatCodes.h = formatCodes.b;\r\nfunction strftime (d, formatStr) {\r\n    var output = '';\r\n    var remaining = formatStr;\r\n    var match;\r\n    while ((match = rFormat.exec(remaining))) {\r\n        output += remaining.slice(0, match.index);\r\n        remaining = remaining.slice(match.index + match[0].length);\r\n        output += format(d, match);\r\n    }\r\n    return output + remaining;\r\n}\r\nfunction format(d, match) {\r\n    var e_1, _a;\r\n    var _b = __read(match, 5), input = _b[0], _c = _b[1], flagStr = _c === void 0 ? '' : _c, width = _b[2], modifier = _b[3], conversion = _b[4];\r\n    var convert = formatCodes[conversion];\r\n    if (!convert)\r\n        return input;\r\n    var flags = {};\r\n    try {\r\n        for (var flagStr_1 = __values(flagStr), flagStr_1_1 = flagStr_1.next(); !flagStr_1_1.done; flagStr_1_1 = flagStr_1.next()) {\r\n            var flag = flagStr_1_1.value;\r\n            flags[flag] = true;\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (flagStr_1_1 && !flagStr_1_1.done && (_a = flagStr_1.return)) _a.call(flagStr_1);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n    var ret = String(convert(d, { flags: flags, width: width, modifier: modifier }));\r\n    var padChar = padChars[conversion] || '0';\r\n    var padWidth = width || padWidths[conversion] || 0;\r\n    if (flags['^'])\r\n        ret = ret.toUpperCase();\r\n    else if (flags['#'])\r\n        ret = changeCase(ret);\r\n    if (flags['_'])\r\n        padChar = ' ';\r\n    else if (flags['0'])\r\n        padChar = '0';\r\n    if (flags['-'])\r\n        padWidth = 0;\r\n    return padStart(ret, padWidth, padChar);\r\n}\n\nfunction date(v, arg) {\r\n    var opts = this.context.opts;\r\n    var date;\r\n    v = toValue$1(v);\r\n    arg = stringify(arg);\r\n    if (v === 'now' || v === 'today') {\r\n        date = new Date();\r\n    }\r\n    else if (isNumber(v)) {\r\n        date = new Date(v * 1000);\r\n    }\r\n    else if (isString(v)) {\r\n        if (/^\\d+$/.test(v)) {\r\n            date = new Date(+v * 1000);\r\n        }\r\n        else if (opts.preserveTimezones) {\r\n            date = TimezoneDate.createDateFixedToTimezone(v);\r\n        }\r\n        else {\r\n            date = new Date(v);\r\n        }\r\n    }\r\n    else {\r\n        date = v;\r\n    }\r\n    if (!isValidDate(date))\r\n        return v;\r\n    if (opts.hasOwnProperty('timezoneOffset')) {\r\n        date = new TimezoneDate(date, opts.timezoneOffset);\r\n    }\r\n    return strftime(date, arg);\r\n}\r\nfunction isValidDate(date) {\r\n    return (date instanceof Date || date instanceof TimezoneDate) && !isNaN(date.getTime());\r\n}\n\nfunction Default(value, defaultValue) {\r\n    var args = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        args[_i - 2] = arguments[_i];\r\n    }\r\n    value = toValue$1(value);\r\n    if (isArray(value) || isString(value))\r\n        return value.length ? value : defaultValue;\r\n    if (value === false && (new Map(args)).get('allow_false'))\r\n        return false;\r\n    return isFalsy(value, this.context) ? defaultValue : value;\r\n}\r\nfunction json(value) {\r\n    return JSON.stringify(value);\r\n}\n\n/**\r\n * String related filters\r\n *\r\n * * prefer stringify() to String() since `undefined`, `null` should eval ''\r\n */\r\nfunction append(v, arg) {\r\n    assert(arguments.length === 2, 'append expect 2 arguments');\r\n    return stringify(v) + stringify(arg);\r\n}\r\nfunction prepend(v, arg) {\r\n    assert(arguments.length === 2, 'prepend expect 2 arguments');\r\n    return stringify(arg) + stringify(v);\r\n}\r\nfunction lstrip(v, chars) {\r\n    if (chars) {\r\n        chars = escapeRegExp(stringify(chars));\r\n        return stringify(v).replace(new RegExp(\"^[\".concat(chars, \"]+\"), 'g'), '');\r\n    }\r\n    return stringify(v).replace(/^\\s+/, '');\r\n}\r\nfunction downcase(v) {\r\n    return stringify(v).toLowerCase();\r\n}\r\nfunction upcase(str) {\r\n    return stringify(str).toUpperCase();\r\n}\r\nfunction remove(v, arg) {\r\n    return stringify(v).split(String(arg)).join('');\r\n}\r\nfunction removeFirst(v, l) {\r\n    return stringify(v).replace(String(l), '');\r\n}\r\nfunction rstrip(str, chars) {\r\n    if (chars) {\r\n        chars = escapeRegExp(stringify(chars));\r\n        return stringify(str).replace(new RegExp(\"[\".concat(chars, \"]+$\"), 'g'), '');\r\n    }\r\n    return stringify(str).replace(/\\s+$/, '');\r\n}\r\nfunction split(v, arg) {\r\n    var arr = stringify(v).split(String(arg));\r\n    // align to ruby split, which is the behavior of shopify/liquid\r\n    // see: https://ruby-doc.org/core-2.4.0/String.html#method-i-split\r\n    while (arr.length && arr[arr.length - 1] === '')\r\n        arr.pop();\r\n    return arr;\r\n}\r\nfunction strip(v, chars) {\r\n    if (chars) {\r\n        chars = escapeRegExp(stringify(chars));\r\n        return stringify(v)\r\n            .replace(new RegExp(\"^[\".concat(chars, \"]+\"), 'g'), '')\r\n            .replace(new RegExp(\"[\".concat(chars, \"]+$\"), 'g'), '');\r\n    }\r\n    return stringify(v).trim();\r\n}\r\nfunction stripNewlines(v) {\r\n    return stringify(v).replace(/\\n/g, '');\r\n}\r\nfunction capitalize(str) {\r\n    str = stringify(str);\r\n    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\r\n}\r\nfunction replace(v, pattern, replacement) {\r\n    return stringify(v).split(String(pattern)).join(replacement);\r\n}\r\nfunction replaceFirst(v, arg1, arg2) {\r\n    return stringify(v).replace(String(arg1), arg2);\r\n}\r\nfunction truncate(v, l, o) {\r\n    if (l === void 0) { l = 50; }\r\n    if (o === void 0) { o = '...'; }\r\n    v = stringify(v);\r\n    if (v.length <= l)\r\n        return v;\r\n    return v.substring(0, l - o.length) + o;\r\n}\r\nfunction truncatewords(v, l, o) {\r\n    if (l === void 0) { l = 15; }\r\n    if (o === void 0) { o = '...'; }\r\n    var arr = stringify(v).split(/\\s+/);\r\n    var ret = arr.slice(0, l).join(' ');\r\n    if (arr.length >= l)\r\n        ret += o;\r\n    return ret;\r\n}\n\nvar builtinFilters = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    escape: escape,\n    escapeOnce: escapeOnce,\n    newlineToBr: newlineToBr,\n    stripHtml: stripHtml,\n    abs: abs,\n    atLeast: atLeast,\n    atMost: atMost,\n    ceil: ceil,\n    dividedBy: dividedBy,\n    floor: floor,\n    minus: minus,\n    modulo: modulo,\n    times: times,\n    round: round,\n    plus: plus,\n    urlDecode: urlDecode,\n    urlEncode: urlEncode,\n    join: join,\n    last: last,\n    first: first,\n    reverse: reverse,\n    sort: sort,\n    sortNatural: sortNatural,\n    size: size,\n    map: map,\n    compact: compact,\n    concat: concat,\n    slice: slice,\n    where: where,\n    uniq: uniq,\n    date: date,\n    Default: Default,\n    json: json,\n    append: append,\n    prepend: prepend,\n    lstrip: lstrip,\n    downcase: downcase,\n    upcase: upcase,\n    remove: remove,\n    removeFirst: removeFirst,\n    rstrip: rstrip,\n    split: split,\n    strip: strip,\n    stripNewlines: stripNewlines,\n    capitalize: capitalize,\n    replace: replace,\n    replaceFirst: replaceFirst,\n    truncate: truncate,\n    truncatewords: truncatewords\n});\n\nvar assign = {\r\n    parse: function (token) {\r\n        var tokenizer = new Tokenizer(token.args, this.liquid.options.operatorsTrie);\r\n        this.key = tokenizer.readIdentifier().content;\r\n        tokenizer.skipBlank();\r\n        assert(tokenizer.peek() === '=', function () { return \"illegal token \".concat(token.getText()); });\r\n        tokenizer.advance();\r\n        this.value = tokenizer.remaining();\r\n    },\r\n    render: function (ctx) {\r\n        var _a, _b;\r\n        return __generator(this, function (_c) {\r\n            switch (_c.label) {\r\n                case 0:\r\n                    _a = ctx.bottom();\r\n                    _b = this.key;\r\n                    return [4 /*yield*/, this.liquid._evalValue(this.value, ctx)];\r\n                case 1:\r\n                    _a[_b] = _c.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    }\r\n};\n\nvar ForloopDrop = /** @class */ (function (_super) {\r\n    __extends(ForloopDrop, _super);\r\n    function ForloopDrop(length, collection, variable) {\r\n        var _this = _super.call(this) || this;\r\n        _this.i = 0;\r\n        _this.length = length;\r\n        _this.name = \"\".concat(variable, \"-\").concat(collection);\r\n        return _this;\r\n    }\r\n    ForloopDrop.prototype.next = function () {\r\n        this.i++;\r\n    };\r\n    ForloopDrop.prototype.index0 = function () {\r\n        return this.i;\r\n    };\r\n    ForloopDrop.prototype.index = function () {\r\n        return this.i + 1;\r\n    };\r\n    ForloopDrop.prototype.first = function () {\r\n        return this.i === 0;\r\n    };\r\n    ForloopDrop.prototype.last = function () {\r\n        return this.i === this.length - 1;\r\n    };\r\n    ForloopDrop.prototype.rindex = function () {\r\n        return this.length - this.i;\r\n    };\r\n    ForloopDrop.prototype.rindex0 = function () {\r\n        return this.length - this.i - 1;\r\n    };\r\n    ForloopDrop.prototype.valueOf = function () {\r\n        return JSON.stringify(this);\r\n    };\r\n    return ForloopDrop;\r\n}(Drop));\n\nvar MODIFIERS = ['offset', 'limit', 'reversed'];\r\nvar For = {\r\n    type: 'block',\r\n    parse: function (token, remainTokens) {\r\n        var _this = this;\r\n        var tokenizer = new Tokenizer(token.args, this.liquid.options.operatorsTrie);\r\n        var variable = tokenizer.readIdentifier();\r\n        var inStr = tokenizer.readIdentifier();\r\n        var collection = tokenizer.readValue();\r\n        assert(variable.size() && inStr.content === 'in' && collection, function () { return \"illegal tag: \".concat(token.getText()); });\r\n        this.variable = variable.content;\r\n        this.collection = collection;\r\n        this.hash = new Hash(tokenizer.remaining());\r\n        this.templates = [];\r\n        this.elseTemplates = [];\r\n        var p;\r\n        var stream = this.liquid.parser.parseStream(remainTokens)\r\n            .on('start', function () { return (p = _this.templates); })\r\n            .on('tag:else', function () { return (p = _this.elseTemplates); })\r\n            .on('tag:endfor', function () { return stream.stop(); })\r\n            .on('template', function (tpl) { return p.push(tpl); })\r\n            .on('end', function () {\r\n            throw new Error(\"tag \".concat(token.getText(), \" not closed\"));\r\n        });\r\n        stream.start();\r\n    },\r\n    render: function (ctx, emitter) {\r\n        var r, collection, _a, continueKey, hash, modifiers, scope, collection_1, collection_1_1, item, e_1_1;\r\n        var e_1, _b;\r\n        return __generator(this, function (_c) {\r\n            switch (_c.label) {\r\n                case 0:\r\n                    r = this.liquid.renderer;\r\n                    _a = toEnumerable;\r\n                    return [4 /*yield*/, evalToken(this.collection, ctx)];\r\n                case 1:\r\n                    collection = _a.apply(void 0, [_c.sent()]);\r\n                    if (!!collection.length) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, r.renderTemplates(this.elseTemplates, ctx, emitter)];\r\n                case 2:\r\n                    _c.sent();\r\n                    return [2 /*return*/];\r\n                case 3:\r\n                    continueKey = 'continue-' + this.variable + '-' + this.collection.getText();\r\n                    ctx.push({ continue: ctx.getRegister(continueKey) });\r\n                    return [4 /*yield*/, this.hash.render(ctx)];\r\n                case 4:\r\n                    hash = _c.sent();\r\n                    ctx.pop();\r\n                    modifiers = this.liquid.options.orderedFilterParameters\r\n                        ? Object.keys(hash).filter(function (x) { return MODIFIERS.includes(x); })\r\n                        : MODIFIERS.filter(function (x) { return hash[x] !== undefined; });\r\n                    collection = modifiers.reduce(function (collection, modifier) {\r\n                        if (modifier === 'offset')\r\n                            return offset(collection, hash['offset']);\r\n                        if (modifier === 'limit')\r\n                            return limit(collection, hash['limit']);\r\n                        return reversed(collection);\r\n                    }, collection);\r\n                    ctx.setRegister(continueKey, (hash['offset'] || 0) + collection.length);\r\n                    scope = { forloop: new ForloopDrop(collection.length, this.collection.getText(), this.variable) };\r\n                    ctx.push(scope);\r\n                    _c.label = 5;\r\n                case 5:\r\n                    _c.trys.push([5, 10, 11, 12]);\r\n                    collection_1 = __values(collection), collection_1_1 = collection_1.next();\r\n                    _c.label = 6;\r\n                case 6:\r\n                    if (!!collection_1_1.done) return [3 /*break*/, 9];\r\n                    item = collection_1_1.value;\r\n                    scope[this.variable] = item;\r\n                    return [4 /*yield*/, r.renderTemplates(this.templates, ctx, emitter)];\r\n                case 7:\r\n                    _c.sent();\r\n                    if (emitter['break']) {\r\n                        emitter['break'] = false;\r\n                        return [3 /*break*/, 9];\r\n                    }\r\n                    emitter['continue'] = false;\r\n                    scope.forloop.next();\r\n                    _c.label = 8;\r\n                case 8:\r\n                    collection_1_1 = collection_1.next();\r\n                    return [3 /*break*/, 6];\r\n                case 9: return [3 /*break*/, 12];\r\n                case 10:\r\n                    e_1_1 = _c.sent();\r\n                    e_1 = { error: e_1_1 };\r\n                    return [3 /*break*/, 12];\r\n                case 11:\r\n                    try {\r\n                        if (collection_1_1 && !collection_1_1.done && (_b = collection_1.return)) _b.call(collection_1);\r\n                    }\r\n                    finally { if (e_1) throw e_1.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 12:\r\n                    ctx.pop();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    }\r\n};\r\nfunction reversed(arr) {\r\n    return __spreadArray([], __read(arr), false).reverse();\r\n}\r\nfunction offset(arr, count) {\r\n    return arr.slice(count);\r\n}\r\nfunction limit(arr, count) {\r\n    return arr.slice(0, count);\r\n}\n\nvar capture = {\r\n    parse: function (tagToken, remainTokens) {\r\n        var _this = this;\r\n        var tokenizer = new Tokenizer(tagToken.args, this.liquid.options.operatorsTrie);\r\n        this.variable = readVariableName(tokenizer);\r\n        assert(this.variable, function () { return \"\".concat(tagToken.args, \" not valid identifier\"); });\r\n        this.templates = [];\r\n        var stream = this.liquid.parser.parseStream(remainTokens);\r\n        stream.on('tag:endcapture', function () { return stream.stop(); })\r\n            .on('template', function (tpl) { return _this.templates.push(tpl); })\r\n            .on('end', function () {\r\n            throw new Error(\"tag \".concat(tagToken.getText(), \" not closed\"));\r\n        });\r\n        stream.start();\r\n    },\r\n    render: function (ctx) {\r\n        var r, html;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    r = this.liquid.renderer;\r\n                    return [4 /*yield*/, r.renderTemplates(this.templates, ctx)];\r\n                case 1:\r\n                    html = _a.sent();\r\n                    ctx.bottom()[this.variable] = html;\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    }\r\n};\r\nfunction readVariableName(tokenizer) {\r\n    var word = tokenizer.readIdentifier().content;\r\n    if (word)\r\n        return word;\r\n    var quoted = tokenizer.readQuoted();\r\n    if (quoted)\r\n        return evalQuotedToken(quoted);\r\n}\n\nvar Case = {\r\n    parse: function (tagToken, remainTokens) {\r\n        var _this = this;\r\n        this.cond = new Value(tagToken.args, this.liquid);\r\n        this.cases = [];\r\n        this.elseTemplates = [];\r\n        var p = [];\r\n        var stream = this.liquid.parser.parseStream(remainTokens)\r\n            .on('tag:when', function (token) {\r\n            p = [];\r\n            var tokenizer = new Tokenizer(token.args, _this.liquid.options.operatorsTrie);\r\n            while (!tokenizer.end()) {\r\n                var value = tokenizer.readValue();\r\n                _this.cases.push({\r\n                    val: value,\r\n                    templates: p\r\n                });\r\n                tokenizer.readTo(',');\r\n            }\r\n        })\r\n            .on('tag:else', function () { return (p = _this.elseTemplates); })\r\n            .on('tag:endcase', function () { return stream.stop(); })\r\n            .on('template', function (tpl) { return p.push(tpl); })\r\n            .on('end', function () {\r\n            throw new Error(\"tag \".concat(tagToken.getText(), \" not closed\"));\r\n        });\r\n        stream.start();\r\n    },\r\n    render: function (ctx, emitter) {\r\n        var r, cond, _a, _b, _c, branch, val, e_1_1;\r\n        var e_1, _d;\r\n        return __generator(this, function (_e) {\r\n            switch (_e.label) {\r\n                case 0:\r\n                    r = this.liquid.renderer;\r\n                    _a = toValue$1;\r\n                    return [4 /*yield*/, this.cond.value(ctx, ctx.opts.lenientIf)];\r\n                case 1:\r\n                    cond = _a.apply(void 0, [_e.sent()]);\r\n                    _e.label = 2;\r\n                case 2:\r\n                    _e.trys.push([2, 7, 8, 9]);\r\n                    _b = __values(this.cases), _c = _b.next();\r\n                    _e.label = 3;\r\n                case 3:\r\n                    if (!!_c.done) return [3 /*break*/, 6];\r\n                    branch = _c.value;\r\n                    val = evalToken(branch.val, ctx, ctx.opts.lenientIf);\r\n                    if (!(val === cond)) return [3 /*break*/, 5];\r\n                    return [4 /*yield*/, r.renderTemplates(branch.templates, ctx, emitter)];\r\n                case 4:\r\n                    _e.sent();\r\n                    return [2 /*return*/];\r\n                case 5:\r\n                    _c = _b.next();\r\n                    return [3 /*break*/, 3];\r\n                case 6: return [3 /*break*/, 9];\r\n                case 7:\r\n                    e_1_1 = _e.sent();\r\n                    e_1 = { error: e_1_1 };\r\n                    return [3 /*break*/, 9];\r\n                case 8:\r\n                    try {\r\n                        if (_c && !_c.done && (_d = _b.return)) _d.call(_b);\r\n                    }\r\n                    finally { if (e_1) throw e_1.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 9: return [4 /*yield*/, r.renderTemplates(this.elseTemplates, ctx, emitter)];\r\n                case 10:\r\n                    _e.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    }\r\n};\n\nvar comment = {\r\n    parse: function (tagToken, remainTokens) {\r\n        var stream = this.liquid.parser.parseStream(remainTokens);\r\n        stream\r\n            .on('token', function (token) {\r\n            if (token.name === 'endcomment')\r\n                stream.stop();\r\n        })\r\n            .on('end', function () {\r\n            throw new Error(\"tag \".concat(tagToken.getText(), \" not closed\"));\r\n        });\r\n        stream.start();\r\n    }\r\n};\n\nvar BlockMode;\r\n(function (BlockMode) {\r\n    /* store rendered html into blocks */\r\n    BlockMode[BlockMode[\"OUTPUT\"] = 0] = \"OUTPUT\";\r\n    /* output rendered html directly */\r\n    BlockMode[BlockMode[\"STORE\"] = 1] = \"STORE\";\r\n})(BlockMode || (BlockMode = {}));\r\nvar BlockMode$1 = BlockMode;\n\nvar render = {\r\n    parseFilePath: parseFilePath,\r\n    renderFilePath: renderFilePath,\r\n    parse: function (token) {\r\n        var args = token.args;\r\n        var tokenizer = new Tokenizer(args, this.liquid.options.operatorsTrie);\r\n        this['file'] = this.parseFilePath(tokenizer, this.liquid);\r\n        this['currentFile'] = token.file;\r\n        while (!tokenizer.end()) {\r\n            tokenizer.skipBlank();\r\n            var begin = tokenizer.p;\r\n            var keyword = tokenizer.readIdentifier();\r\n            if (keyword.content === 'with' || keyword.content === 'for') {\r\n                tokenizer.skipBlank();\r\n                // can be normal key/value pair, like \"with: true\"\r\n                if (tokenizer.peek() !== ':') {\r\n                    var value = tokenizer.readValue();\r\n                    // can be normal key, like \"with,\"\r\n                    if (value) {\r\n                        var beforeAs = tokenizer.p;\r\n                        var asStr = tokenizer.readIdentifier();\r\n                        var alias = void 0;\r\n                        if (asStr.content === 'as')\r\n                            alias = tokenizer.readIdentifier();\r\n                        else\r\n                            tokenizer.p = beforeAs;\r\n                        this[keyword.content] = { value: value, alias: alias && alias.content };\r\n                        tokenizer.skipBlank();\r\n                        if (tokenizer.peek() === ',')\r\n                            tokenizer.advance();\r\n                        // matched!\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n            /**\r\n             * restore cursor if with/for not matched\r\n             */\r\n            tokenizer.p = begin;\r\n            break;\r\n        }\r\n        this.hash = new Hash(tokenizer.remaining());\r\n    },\r\n    render: function (ctx, emitter) {\r\n        var _a, liquid, hash, filepath, childCtx, scope, _b, _c, _d, value, alias, _e, value, alias, collection, collection_1, collection_1_1, item, templates, e_1_1, templates;\r\n        var e_1, _f;\r\n        return __generator(this, function (_g) {\r\n            switch (_g.label) {\r\n                case 0:\r\n                    _a = this, liquid = _a.liquid, hash = _a.hash;\r\n                    return [4 /*yield*/, this.renderFilePath(this['file'], ctx, liquid)];\r\n                case 1:\r\n                    filepath = _g.sent();\r\n                    assert(filepath, function () { return \"illegal filename \\\"\".concat(filepath, \"\\\"\"); });\r\n                    childCtx = new Context({}, ctx.opts, { sync: ctx.sync, globals: ctx.globals, strictVariables: ctx.strictVariables });\r\n                    scope = childCtx.bottom();\r\n                    _b = __assign;\r\n                    _c = [scope];\r\n                    return [4 /*yield*/, hash.render(ctx)];\r\n                case 2:\r\n                    _b.apply(void 0, _c.concat([_g.sent()]));\r\n                    if (this['with']) {\r\n                        _d = this['with'], value = _d.value, alias = _d.alias;\r\n                        scope[alias || filepath] = evalToken(value, ctx);\r\n                    }\r\n                    if (!this['for']) return [3 /*break*/, 12];\r\n                    _e = this['for'], value = _e.value, alias = _e.alias;\r\n                    collection = evalToken(value, ctx);\r\n                    collection = toEnumerable(collection);\r\n                    scope['forloop'] = new ForloopDrop(collection.length, value.getText(), alias);\r\n                    _g.label = 3;\r\n                case 3:\r\n                    _g.trys.push([3, 9, 10, 11]);\r\n                    collection_1 = __values(collection), collection_1_1 = collection_1.next();\r\n                    _g.label = 4;\r\n                case 4:\r\n                    if (!!collection_1_1.done) return [3 /*break*/, 8];\r\n                    item = collection_1_1.value;\r\n                    scope[alias] = item;\r\n                    return [4 /*yield*/, liquid._parsePartialFile(filepath, childCtx.sync, this['currentFile'])];\r\n                case 5:\r\n                    templates = _g.sent();\r\n                    return [4 /*yield*/, liquid.renderer.renderTemplates(templates, childCtx, emitter)];\r\n                case 6:\r\n                    _g.sent();\r\n                    scope['forloop'].next();\r\n                    _g.label = 7;\r\n                case 7:\r\n                    collection_1_1 = collection_1.next();\r\n                    return [3 /*break*/, 4];\r\n                case 8: return [3 /*break*/, 11];\r\n                case 9:\r\n                    e_1_1 = _g.sent();\r\n                    e_1 = { error: e_1_1 };\r\n                    return [3 /*break*/, 11];\r\n                case 10:\r\n                    try {\r\n                        if (collection_1_1 && !collection_1_1.done && (_f = collection_1.return)) _f.call(collection_1);\r\n                    }\r\n                    finally { if (e_1) throw e_1.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 11: return [3 /*break*/, 15];\r\n                case 12: return [4 /*yield*/, liquid._parsePartialFile(filepath, childCtx.sync, this['currentFile'])];\r\n                case 13:\r\n                    templates = _g.sent();\r\n                    return [4 /*yield*/, liquid.renderer.renderTemplates(templates, childCtx, emitter)];\r\n                case 14:\r\n                    _g.sent();\r\n                    _g.label = 15;\r\n                case 15: return [2 /*return*/];\r\n            }\r\n        });\r\n    }\r\n};\r\n/**\r\n * @return null for \"none\",\r\n * @return Template[] for quoted with tags and/or filters\r\n * @return Token for expression (not quoted)\r\n * @throws TypeError if cannot read next token\r\n */\r\nfunction parseFilePath(tokenizer, liquid) {\r\n    if (liquid.options.dynamicPartials) {\r\n        var file = tokenizer.readValue();\r\n        if (file === undefined)\r\n            throw new TypeError(\"illegal argument \\\"\".concat(tokenizer.input, \"\\\"\"));\r\n        if (file.getText() === 'none')\r\n            return null;\r\n        if (isQuotedToken(file)) {\r\n            // for filenames like \"files/{{file}}\", eval as liquid template\r\n            var templates_1 = liquid.parse(evalQuotedToken(file));\r\n            return optimize(templates_1);\r\n        }\r\n        return file;\r\n    }\r\n    var tokens = __spreadArray([], __read(tokenizer.readFileNameTemplate(liquid.options)), false);\r\n    var templates = optimize(liquid.parser.parseTokens(tokens));\r\n    return templates === 'none' ? null : templates;\r\n}\r\nfunction optimize(templates) {\r\n    // for filenames like \"files/file.liquid\", extract the string directly\r\n    if (templates.length === 1 && isHTMLToken(templates[0].token))\r\n        return templates[0].token.getContent();\r\n    return templates;\r\n}\r\nfunction renderFilePath(file, ctx, liquid) {\r\n    if (typeof file === 'string')\r\n        return file;\r\n    if (Array.isArray(file))\r\n        return liquid.renderer.renderTemplates(file, ctx);\r\n    return evalToken(file, ctx);\r\n}\n\nvar include = {\r\n    parseFilePath: parseFilePath,\r\n    renderFilePath: renderFilePath,\r\n    parse: function (token) {\r\n        var args = token.args;\r\n        var tokenizer = new Tokenizer(args, this.liquid.options.operatorsTrie);\r\n        this['file'] = this.parseFilePath(tokenizer, this.liquid);\r\n        this['currentFile'] = token.file;\r\n        var begin = tokenizer.p;\r\n        var withStr = tokenizer.readIdentifier();\r\n        if (withStr.content === 'with') {\r\n            tokenizer.skipBlank();\r\n            if (tokenizer.peek() !== ':') {\r\n                this.withVar = tokenizer.readValue();\r\n            }\r\n            else\r\n                tokenizer.p = begin;\r\n        }\r\n        else\r\n            tokenizer.p = begin;\r\n        this.hash = new Hash(tokenizer.remaining(), this.liquid.options.jekyllInclude);\r\n    },\r\n    render: function (ctx, emitter) {\r\n        var _a, liquid, hash, withVar, renderer, filepath, saved, scope, templates;\r\n        return __generator(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0:\r\n                    _a = this, liquid = _a.liquid, hash = _a.hash, withVar = _a.withVar;\r\n                    renderer = liquid.renderer;\r\n                    return [4 /*yield*/, this.renderFilePath(this['file'], ctx, liquid)];\r\n                case 1:\r\n                    filepath = _b.sent();\r\n                    assert(filepath, function () { return \"illegal filename \\\"\".concat(filepath, \"\\\"\"); });\r\n                    saved = ctx.saveRegister('blocks', 'blockMode');\r\n                    ctx.setRegister('blocks', {});\r\n                    ctx.setRegister('blockMode', BlockMode$1.OUTPUT);\r\n                    return [4 /*yield*/, hash.render(ctx)];\r\n                case 2:\r\n                    scope = _b.sent();\r\n                    if (withVar)\r\n                        scope[filepath] = evalToken(withVar, ctx);\r\n                    return [4 /*yield*/, liquid._parsePartialFile(filepath, ctx.sync, this['currentFile'])];\r\n                case 3:\r\n                    templates = _b.sent();\r\n                    ctx.push(ctx.opts.jekyllInclude ? { include: scope } : scope);\r\n                    return [4 /*yield*/, renderer.renderTemplates(templates, ctx, emitter)];\r\n                case 4:\r\n                    _b.sent();\r\n                    ctx.pop();\r\n                    ctx.restoreRegister(saved);\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    }\r\n};\n\nvar decrement = {\r\n    parse: function (token) {\r\n        var tokenizer = new Tokenizer(token.args, this.liquid.options.operatorsTrie);\r\n        this.variable = tokenizer.readIdentifier().content;\r\n    },\r\n    render: function (context, emitter) {\r\n        var scope = context.environments;\r\n        if (!isNumber(scope[this.variable])) {\r\n            scope[this.variable] = 0;\r\n        }\r\n        emitter.write(stringify(--scope[this.variable]));\r\n    }\r\n};\n\nvar cycle = {\r\n    parse: function (tagToken) {\r\n        var tokenizer = new Tokenizer(tagToken.args, this.liquid.options.operatorsTrie);\r\n        var group = tokenizer.readValue();\r\n        tokenizer.skipBlank();\r\n        this.candidates = [];\r\n        if (group) {\r\n            if (tokenizer.peek() === ':') {\r\n                this.group = group;\r\n                tokenizer.advance();\r\n            }\r\n            else\r\n                this.candidates.push(group);\r\n        }\r\n        while (!tokenizer.end()) {\r\n            var value = tokenizer.readValue();\r\n            if (value)\r\n                this.candidates.push(value);\r\n            tokenizer.readTo(',');\r\n        }\r\n        assert(this.candidates.length, function () { return \"empty candidates: \".concat(tagToken.getText()); });\r\n    },\r\n    render: function (ctx, emitter) {\r\n        var group = evalToken(this.group, ctx);\r\n        var fingerprint = \"cycle:\".concat(group, \":\") + this.candidates.join(',');\r\n        var groups = ctx.getRegister('cycle');\r\n        var idx = groups[fingerprint];\r\n        if (idx === undefined) {\r\n            idx = groups[fingerprint] = 0;\r\n        }\r\n        var candidate = this.candidates[idx];\r\n        idx = (idx + 1) % this.candidates.length;\r\n        groups[fingerprint] = idx;\r\n        var html = evalToken(candidate, ctx);\r\n        emitter.write(html);\r\n    }\r\n};\n\nvar If = {\r\n    parse: function (tagToken, remainTokens) {\r\n        var _this = this;\r\n        this.branches = [];\r\n        this.elseTemplates = [];\r\n        var p;\r\n        this.liquid.parser.parseStream(remainTokens)\r\n            .on('start', function () { return _this.branches.push({\r\n            predicate: new Value(tagToken.args, _this.liquid),\r\n            templates: (p = [])\r\n        }); })\r\n            .on('tag:elsif', function (token) { return _this.branches.push({\r\n            predicate: new Value(token.args, _this.liquid),\r\n            templates: (p = [])\r\n        }); })\r\n            .on('tag:else', function () { return (p = _this.elseTemplates); })\r\n            .on('tag:endif', function () { this.stop(); })\r\n            .on('template', function (tpl) { return p.push(tpl); })\r\n            .on('end', function () { throw new Error(\"tag \".concat(tagToken.getText(), \" not closed\")); })\r\n            .start();\r\n    },\r\n    render: function (ctx, emitter) {\r\n        var r, _a, _b, _c, predicate, templates, value, e_1_1;\r\n        var e_1, _d;\r\n        return __generator(this, function (_e) {\r\n            switch (_e.label) {\r\n                case 0:\r\n                    r = this.liquid.renderer;\r\n                    _e.label = 1;\r\n                case 1:\r\n                    _e.trys.push([1, 7, 8, 9]);\r\n                    _a = __values(this.branches), _b = _a.next();\r\n                    _e.label = 2;\r\n                case 2:\r\n                    if (!!_b.done) return [3 /*break*/, 6];\r\n                    _c = _b.value, predicate = _c.predicate, templates = _c.templates;\r\n                    return [4 /*yield*/, predicate.value(ctx, ctx.opts.lenientIf)];\r\n                case 3:\r\n                    value = _e.sent();\r\n                    if (!isTruthy(value, ctx)) return [3 /*break*/, 5];\r\n                    return [4 /*yield*/, r.renderTemplates(templates, ctx, emitter)];\r\n                case 4:\r\n                    _e.sent();\r\n                    return [2 /*return*/];\r\n                case 5:\r\n                    _b = _a.next();\r\n                    return [3 /*break*/, 2];\r\n                case 6: return [3 /*break*/, 9];\r\n                case 7:\r\n                    e_1_1 = _e.sent();\r\n                    e_1 = { error: e_1_1 };\r\n                    return [3 /*break*/, 9];\r\n                case 8:\r\n                    try {\r\n                        if (_b && !_b.done && (_d = _a.return)) _d.call(_a);\r\n                    }\r\n                    finally { if (e_1) throw e_1.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 9: return [4 /*yield*/, r.renderTemplates(this.elseTemplates, ctx, emitter)];\r\n                case 10:\r\n                    _e.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    }\r\n};\n\nvar increment = {\r\n    parse: function (token) {\r\n        var tokenizer = new Tokenizer(token.args, this.liquid.options.operatorsTrie);\r\n        this.variable = tokenizer.readIdentifier().content;\r\n    },\r\n    render: function (context, emitter) {\r\n        var scope = context.environments;\r\n        if (!isNumber(scope[this.variable])) {\r\n            scope[this.variable] = 0;\r\n        }\r\n        var val = scope[this.variable];\r\n        scope[this.variable]++;\r\n        emitter.write(stringify(val));\r\n    }\r\n};\n\nvar layout = {\r\n    parseFilePath: parseFilePath,\r\n    renderFilePath: renderFilePath,\r\n    parse: function (token, remainTokens) {\r\n        var tokenizer = new Tokenizer(token.args, this.liquid.options.operatorsTrie);\r\n        this['file'] = this.parseFilePath(tokenizer, this.liquid);\r\n        this['currentFile'] = token.file;\r\n        this.hash = new Hash(tokenizer.remaining());\r\n        this.tpls = this.liquid.parser.parseTokens(remainTokens);\r\n    },\r\n    render: function (ctx, emitter) {\r\n        var _a, liquid, hash, file, renderer, filepath, templates, html, blocks, _b, _c;\r\n        return __generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0:\r\n                    _a = this, liquid = _a.liquid, hash = _a.hash, file = _a.file;\r\n                    renderer = liquid.renderer;\r\n                    if (!(file === null)) return [3 /*break*/, 2];\r\n                    ctx.setRegister('blockMode', BlockMode$1.OUTPUT);\r\n                    return [4 /*yield*/, renderer.renderTemplates(this.tpls, ctx, emitter)];\r\n                case 1:\r\n                    _d.sent();\r\n                    return [2 /*return*/];\r\n                case 2: return [4 /*yield*/, this.renderFilePath(this['file'], ctx, liquid)];\r\n                case 3:\r\n                    filepath = _d.sent();\r\n                    assert(filepath, function () { return \"illegal filename \\\"\".concat(filepath, \"\\\"\"); });\r\n                    return [4 /*yield*/, liquid._parseLayoutFile(filepath, ctx.sync, this['currentFile'])\r\n                        // render remaining contents and store rendered results\r\n                    ];\r\n                case 4:\r\n                    templates = _d.sent();\r\n                    // render remaining contents and store rendered results\r\n                    ctx.setRegister('blockMode', BlockMode$1.STORE);\r\n                    return [4 /*yield*/, renderer.renderTemplates(this.tpls, ctx)];\r\n                case 5:\r\n                    html = _d.sent();\r\n                    blocks = ctx.getRegister('blocks');\r\n                    // set whole content to anonymous block if anonymous doesn't specified\r\n                    if (blocks[''] === undefined)\r\n                        blocks[''] = function (parent, emitter) { return emitter.write(html); };\r\n                    ctx.setRegister('blockMode', BlockMode$1.OUTPUT);\r\n                    // render the layout file use stored blocks\r\n                    _c = (_b = ctx).push;\r\n                    return [4 /*yield*/, hash.render(ctx)];\r\n                case 6:\r\n                    // render the layout file use stored blocks\r\n                    _c.apply(_b, [_d.sent()]);\r\n                    return [4 /*yield*/, renderer.renderTemplates(templates, ctx, emitter)];\r\n                case 7:\r\n                    _d.sent();\r\n                    ctx.pop();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    }\r\n};\n\nvar BlockDrop = /** @class */ (function (_super) {\r\n    __extends(BlockDrop, _super);\r\n    function BlockDrop(\r\n    // the block render from layout template\r\n    superBlockRender) {\r\n        if (superBlockRender === void 0) { superBlockRender = function () { return ''; }; }\r\n        var _this = _super.call(this) || this;\r\n        _this.superBlockRender = superBlockRender;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Provide parent access in child block by\r\n     * {{ block.super }}\r\n     */\r\n    BlockDrop.prototype.super = function () {\r\n        return this.superBlockRender();\r\n    };\r\n    return BlockDrop;\r\n}(Drop));\n\nvar block = {\r\n    parse: function (token, remainTokens) {\r\n        var _this = this;\r\n        var match = /\\w+/.exec(token.args);\r\n        this.block = match ? match[0] : '';\r\n        this.tpls = [];\r\n        this.liquid.parser.parseStream(remainTokens)\r\n            .on('tag:endblock', function () { this.stop(); })\r\n            .on('template', function (tpl) { return _this.tpls.push(tpl); })\r\n            .on('end', function () { throw new Error(\"tag \".concat(token.getText(), \" not closed\")); })\r\n            .start();\r\n    },\r\n    render: function (ctx, emitter) {\r\n        var blockRender;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    blockRender = this.getBlockRender(ctx);\r\n                    if (!(ctx.getRegister('blockMode') === BlockMode$1.STORE)) return [3 /*break*/, 1];\r\n                    ctx.getRegister('blocks')[this.block] = blockRender;\r\n                    return [3 /*break*/, 3];\r\n                case 1: return [4 /*yield*/, blockRender(new BlockDrop(), emitter)];\r\n                case 2:\r\n                    _a.sent();\r\n                    _a.label = 3;\r\n                case 3: return [2 /*return*/];\r\n            }\r\n        });\r\n    },\r\n    getBlockRender: function (ctx) {\r\n        var _a = this, liquid = _a.liquid, tpls = _a.tpls;\r\n        var renderChild = ctx.getRegister('blocks')[this.block];\r\n        var renderCurrent = function (superBlock, emitter) {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        // add {{ block.super }} support when rendering\r\n                        ctx.push({ block: superBlock });\r\n                        return [4 /*yield*/, liquid.renderer.renderTemplates(tpls, ctx, emitter)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        ctx.pop();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        };\r\n        return renderChild\r\n            ? function (superBlock, emitter) { return renderChild(new BlockDrop(function () { return renderCurrent(superBlock, emitter); }), emitter); }\r\n            : renderCurrent;\r\n    }\r\n};\n\nvar raw = {\r\n    parse: function (tagToken, remainTokens) {\r\n        var _this = this;\r\n        this.tokens = [];\r\n        var stream = this.liquid.parser.parseStream(remainTokens);\r\n        stream\r\n            .on('token', function (token) {\r\n            if (token.name === 'endraw')\r\n                stream.stop();\r\n            else\r\n                _this.tokens.push(token);\r\n        })\r\n            .on('end', function () {\r\n            throw new Error(\"tag \".concat(tagToken.getText(), \" not closed\"));\r\n        });\r\n        stream.start();\r\n    },\r\n    render: function () {\r\n        return this.tokens.map(function (token) { return token.getText(); }).join('');\r\n    }\r\n};\n\nvar TablerowloopDrop = /** @class */ (function (_super) {\r\n    __extends(TablerowloopDrop, _super);\r\n    function TablerowloopDrop(length, cols, collection, variable) {\r\n        var _this = _super.call(this, length, collection, variable) || this;\r\n        _this.length = length;\r\n        _this.cols = cols;\r\n        return _this;\r\n    }\r\n    TablerowloopDrop.prototype.row = function () {\r\n        return Math.floor(this.i / this.cols) + 1;\r\n    };\r\n    TablerowloopDrop.prototype.col0 = function () {\r\n        return (this.i % this.cols);\r\n    };\r\n    TablerowloopDrop.prototype.col = function () {\r\n        return this.col0() + 1;\r\n    };\r\n    TablerowloopDrop.prototype.col_first = function () {\r\n        return this.col0() === 0;\r\n    };\r\n    TablerowloopDrop.prototype.col_last = function () {\r\n        return this.col() === this.cols;\r\n    };\r\n    return TablerowloopDrop;\r\n}(ForloopDrop));\n\nvar tablerow = {\r\n    parse: function (tagToken, remainTokens) {\r\n        var _this = this;\r\n        var tokenizer = new Tokenizer(tagToken.args, this.liquid.options.operatorsTrie);\r\n        var variable = tokenizer.readIdentifier();\r\n        tokenizer.skipBlank();\r\n        var tmp = tokenizer.readIdentifier();\r\n        assert(tmp && tmp.content === 'in', function () { return \"illegal tag: \".concat(tagToken.getText()); });\r\n        this.variable = variable.content;\r\n        this.collection = tokenizer.readValue();\r\n        this.hash = new Hash(tokenizer.remaining());\r\n        this.templates = [];\r\n        var p;\r\n        var stream = this.liquid.parser.parseStream(remainTokens)\r\n            .on('start', function () { return (p = _this.templates); })\r\n            .on('tag:endtablerow', function () { return stream.stop(); })\r\n            .on('template', function (tpl) { return p.push(tpl); })\r\n            .on('end', function () {\r\n            throw new Error(\"tag \".concat(tagToken.getText(), \" not closed\"));\r\n        });\r\n        stream.start();\r\n    },\r\n    render: function (ctx, emitter) {\r\n        var collection, _a, hash, offset, limit, cols, r, tablerowloop, scope, idx;\r\n        return __generator(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0:\r\n                    _a = toEnumerable;\r\n                    return [4 /*yield*/, evalToken(this.collection, ctx)];\r\n                case 1:\r\n                    collection = _a.apply(void 0, [_b.sent()]);\r\n                    return [4 /*yield*/, this.hash.render(ctx)];\r\n                case 2:\r\n                    hash = _b.sent();\r\n                    offset = hash.offset || 0;\r\n                    limit = (hash.limit === undefined) ? collection.length : hash.limit;\r\n                    collection = collection.slice(offset, offset + limit);\r\n                    cols = hash.cols || collection.length;\r\n                    r = this.liquid.renderer;\r\n                    tablerowloop = new TablerowloopDrop(collection.length, cols, this.collection.getText(), this.variable);\r\n                    scope = { tablerowloop: tablerowloop };\r\n                    ctx.push(scope);\r\n                    idx = 0;\r\n                    _b.label = 3;\r\n                case 3:\r\n                    if (!(idx < collection.length)) return [3 /*break*/, 6];\r\n                    scope[this.variable] = collection[idx];\r\n                    if (tablerowloop.col0() === 0) {\r\n                        if (tablerowloop.row() !== 1)\r\n                            emitter.write('</tr>');\r\n                        emitter.write(\"<tr class=\\\"row\".concat(tablerowloop.row(), \"\\\">\"));\r\n                    }\r\n                    emitter.write(\"<td class=\\\"col\".concat(tablerowloop.col(), \"\\\">\"));\r\n                    return [4 /*yield*/, r.renderTemplates(this.templates, ctx, emitter)];\r\n                case 4:\r\n                    _b.sent();\r\n                    emitter.write('</td>');\r\n                    _b.label = 5;\r\n                case 5:\r\n                    idx++, tablerowloop.next();\r\n                    return [3 /*break*/, 3];\r\n                case 6:\r\n                    if (collection.length)\r\n                        emitter.write('</tr>');\r\n                    ctx.pop();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    }\r\n};\n\nvar unless = {\r\n    parse: function (tagToken, remainTokens) {\r\n        var _this = this;\r\n        this.branches = [];\r\n        this.elseTemplates = [];\r\n        var p;\r\n        this.liquid.parser.parseStream(remainTokens)\r\n            .on('start', function () { return _this.branches.push({\r\n            predicate: new Value(tagToken.args, _this.liquid),\r\n            test: isFalsy,\r\n            templates: (p = [])\r\n        }); })\r\n            .on('tag:elsif', function (token) { return _this.branches.push({\r\n            predicate: new Value(token.args, _this.liquid),\r\n            test: isTruthy,\r\n            templates: (p = [])\r\n        }); })\r\n            .on('tag:else', function () { return (p = _this.elseTemplates); })\r\n            .on('tag:endunless', function () { this.stop(); })\r\n            .on('template', function (tpl) { return p.push(tpl); })\r\n            .on('end', function () { throw new Error(\"tag \".concat(tagToken.getText(), \" not closed\")); })\r\n            .start();\r\n    },\r\n    render: function (ctx, emitter) {\r\n        var r, _a, _b, _c, predicate, test_1, templates, value, e_1_1;\r\n        var e_1, _d;\r\n        return __generator(this, function (_e) {\r\n            switch (_e.label) {\r\n                case 0:\r\n                    r = this.liquid.renderer;\r\n                    _e.label = 1;\r\n                case 1:\r\n                    _e.trys.push([1, 7, 8, 9]);\r\n                    _a = __values(this.branches), _b = _a.next();\r\n                    _e.label = 2;\r\n                case 2:\r\n                    if (!!_b.done) return [3 /*break*/, 6];\r\n                    _c = _b.value, predicate = _c.predicate, test_1 = _c.test, templates = _c.templates;\r\n                    return [4 /*yield*/, predicate.value(ctx, ctx.opts.lenientIf)];\r\n                case 3:\r\n                    value = _e.sent();\r\n                    if (!test_1(value, ctx)) return [3 /*break*/, 5];\r\n                    return [4 /*yield*/, r.renderTemplates(templates, ctx, emitter)];\r\n                case 4:\r\n                    _e.sent();\r\n                    return [2 /*return*/];\r\n                case 5:\r\n                    _b = _a.next();\r\n                    return [3 /*break*/, 2];\r\n                case 6: return [3 /*break*/, 9];\r\n                case 7:\r\n                    e_1_1 = _e.sent();\r\n                    e_1 = { error: e_1_1 };\r\n                    return [3 /*break*/, 9];\r\n                case 8:\r\n                    try {\r\n                        if (_b && !_b.done && (_d = _a.return)) _d.call(_a);\r\n                    }\r\n                    finally { if (e_1) throw e_1.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 9: return [4 /*yield*/, r.renderTemplates(this.elseTemplates, ctx, emitter)];\r\n                case 10:\r\n                    _e.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    }\r\n};\n\nvar Break = {\r\n    render: function (ctx, emitter) {\r\n        emitter['break'] = true;\r\n    }\r\n};\n\nvar Continue = {\r\n    render: function (ctx, emitter) {\r\n        emitter['continue'] = true;\r\n    }\r\n};\n\nvar echo = {\r\n    parse: function (token) {\r\n        this.value = new Value(token.args, this.liquid);\r\n    },\r\n    render: function (ctx, emitter) {\r\n        var val;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, this.value.value(ctx, false)];\r\n                case 1:\r\n                    val = _a.sent();\r\n                    emitter.write(val);\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    }\r\n};\n\nvar liquid = {\r\n    parse: function (token) {\r\n        var tokenizer = new Tokenizer(token.args, this.liquid.options.operatorsTrie);\r\n        var tokens = tokenizer.readLiquidTagTokens(this.liquid.options);\r\n        this.tpls = this.liquid.parser.parseTokens(tokens);\r\n    },\r\n    render: function (ctx, emitter) {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, this.liquid.renderer.renderTemplates(this.tpls, ctx, emitter)];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    }\r\n};\n\nvar tags = {\r\n    assign: assign,\r\n    'for': For,\r\n    capture: capture,\r\n    'case': Case,\r\n    comment: comment,\r\n    include: include,\r\n    render: render,\r\n    decrement: decrement,\r\n    increment: increment,\r\n    cycle: cycle,\r\n    'if': If,\r\n    layout: layout,\r\n    block: block,\r\n    raw: raw,\r\n    tablerow: tablerow,\r\n    unless: unless,\r\n    'break': Break, 'continue': Continue,\r\n    echo: echo,\r\n    liquid: liquid\r\n};\n\nvar index = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    'default': tags\n});\n\nvar Tag = /** @class */ (function (_super) {\r\n    __extends(Tag, _super);\r\n    function Tag(token, tokens, liquid) {\r\n        var _this = _super.call(this, token) || this;\r\n        _this.name = token.name;\r\n        var impl = liquid.tags.get(token.name);\r\n        _this.impl = Object.create(impl);\r\n        _this.impl.liquid = liquid;\r\n        if (_this.impl.parse) {\r\n            _this.impl.parse(token, tokens);\r\n        }\r\n        return _this;\r\n    }\r\n    Tag.prototype.render = function (ctx, emitter) {\r\n        var hash, impl;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, new Hash(this.token.args).render(ctx)];\r\n                case 1:\r\n                    hash = (_a.sent());\r\n                    impl = this.impl;\r\n                    if (!isFunction(impl.render)) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, impl.render(ctx, emitter, hash)];\r\n                case 2: return [2 /*return*/, _a.sent()];\r\n                case 3: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    return Tag;\r\n}(TemplateImpl));\n\nvar Output = /** @class */ (function (_super) {\r\n    __extends(Output, _super);\r\n    function Output(token, liquid) {\r\n        var _this = _super.call(this, token) || this;\r\n        _this.value = new Value(token.content, liquid);\r\n        return _this;\r\n    }\r\n    Output.prototype.render = function (ctx, emitter) {\r\n        var val;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, this.value.value(ctx, false)];\r\n                case 1:\r\n                    val = _a.sent();\r\n                    emitter.write(val);\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    return Output;\r\n}(TemplateImpl));\n\nvar HTML = /** @class */ (function (_super) {\r\n    __extends(HTML, _super);\r\n    function HTML(token) {\r\n        var _this = _super.call(this, token) || this;\r\n        _this.str = token.getContent();\r\n        return _this;\r\n    }\r\n    HTML.prototype.render = function (ctx, emitter) {\r\n        return __generator(this, function (_a) {\r\n            emitter.write(this.str);\r\n            return [2 /*return*/];\r\n        });\r\n    };\r\n    return HTML;\r\n}(TemplateImpl));\n\nvar Parser = /** @class */ (function () {\r\n    function Parser(liquid) {\r\n        this.liquid = liquid;\r\n        this.cache = this.liquid.options.cache;\r\n        this.fs = this.liquid.options.fs;\r\n        this.parseFile = this.cache ? this._parseFileCached : this._parseFile;\r\n        this.loader = new Loader(this.liquid.options);\r\n    }\r\n    Parser.prototype.parse = function (html, filepath) {\r\n        var tokenizer = new Tokenizer(html, this.liquid.options.operatorsTrie, filepath);\r\n        var tokens = tokenizer.readTopLevelTokens(this.liquid.options);\r\n        return this.parseTokens(tokens);\r\n    };\r\n    Parser.prototype.parseTokens = function (tokens) {\r\n        var token;\r\n        var templates = [];\r\n        while ((token = tokens.shift())) {\r\n            templates.push(this.parseToken(token, tokens));\r\n        }\r\n        return templates;\r\n    };\r\n    Parser.prototype.parseToken = function (token, remainTokens) {\r\n        try {\r\n            if (isTagToken(token)) {\r\n                return new Tag(token, remainTokens, this.liquid);\r\n            }\r\n            if (isOutputToken(token)) {\r\n                return new Output(token, this.liquid);\r\n            }\r\n            return new HTML(token);\r\n        }\r\n        catch (e) {\r\n            throw new ParseError(e, token);\r\n        }\r\n    };\r\n    Parser.prototype.parseStream = function (tokens) {\r\n        var _this = this;\r\n        return new ParseStream(tokens, function (token, tokens) { return _this.parseToken(token, tokens); });\r\n    };\r\n    Parser.prototype._parseFileCached = function (file, sync, type, currentFile) {\r\n        var key, tpls, task;\r\n        if (type === void 0) { type = LookupType.Root; }\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    key = this.loader.shouldLoadRelative(file)\r\n                        ? currentFile + ',' + file\r\n                        : type + ':' + file;\r\n                    return [4 /*yield*/, this.cache.read(key)];\r\n                case 1:\r\n                    tpls = _a.sent();\r\n                    if (tpls)\r\n                        return [2 /*return*/, tpls];\r\n                    task = toThenable(this._parseFile(file, sync, type, currentFile));\r\n                    this.cache.write(key, task);\r\n                    _a.label = 2;\r\n                case 2:\r\n                    _a.trys.push([2, 4, , 5]);\r\n                    return [4 /*yield*/, task];\r\n                case 3: return [2 /*return*/, _a.sent()];\r\n                case 4:\r\n                    _a.sent();\r\n                    // remove cached task if failed\r\n                    this.cache.remove(key);\r\n                    return [3 /*break*/, 5];\r\n                case 5: return [2 /*return*/, []];\r\n            }\r\n        });\r\n    };\r\n    Parser.prototype._parseFile = function (file, sync, type, currentFile) {\r\n        var filepath, _a, _b, _c;\r\n        if (type === void 0) { type = LookupType.Root; }\r\n        return __generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0: return [4 /*yield*/, this.loader.lookup(file, type, sync, currentFile)];\r\n                case 1:\r\n                    filepath = _d.sent();\r\n                    _b = (_a = this.liquid).parse;\r\n                    if (!sync) return [3 /*break*/, 2];\r\n                    _c = this.fs.readFileSync(filepath);\r\n                    return [3 /*break*/, 4];\r\n                case 2: return [4 /*yield*/, this.fs.readFile(filepath)];\r\n                case 3:\r\n                    _c = _d.sent();\r\n                    _d.label = 4;\r\n                case 4: return [2 /*return*/, _b.apply(_a, [_c, filepath])];\r\n            }\r\n        });\r\n    };\r\n    return Parser;\r\n}());\n\nvar TagMap = /** @class */ (function () {\r\n    function TagMap() {\r\n        this.impls = {};\r\n    }\r\n    TagMap.prototype.get = function (name) {\r\n        var impl = this.impls[name];\r\n        assert(impl, function () { return \"tag \\\"\".concat(name, \"\\\" not found\"); });\r\n        return impl;\r\n    };\r\n    TagMap.prototype.set = function (name, impl) {\r\n        this.impls[name] = impl;\r\n    };\r\n    return TagMap;\r\n}());\n\nvar FilterMap = /** @class */ (function () {\r\n    function FilterMap(strictFilters, liquid) {\r\n        this.strictFilters = strictFilters;\r\n        this.liquid = liquid;\r\n        this.impls = {};\r\n    }\r\n    FilterMap.prototype.get = function (name) {\r\n        var impl = this.impls[name];\r\n        assert(impl || !this.strictFilters, function () { return \"undefined filter: \".concat(name); });\r\n        return impl;\r\n    };\r\n    FilterMap.prototype.set = function (name, impl) {\r\n        this.impls[name] = impl;\r\n    };\r\n    FilterMap.prototype.create = function (name, args) {\r\n        return new Filter(name, this.get(name), args, this.liquid);\r\n    };\r\n    return FilterMap;\r\n}());\n\nvar version = '9.36.0';\r\nvar Liquid = /** @class */ (function () {\r\n    function Liquid(opts) {\r\n        var _this = this;\r\n        if (opts === void 0) { opts = {}; }\r\n        this.options = normalize(opts);\r\n        this.parser = new Parser(this);\r\n        this.renderer = new Render();\r\n        this.filters = new FilterMap(this.options.strictFilters, this);\r\n        this.tags = new TagMap();\r\n        forOwn(tags, function (conf, name) { return _this.registerTag(snakeCase(name), conf); });\r\n        forOwn(builtinFilters, function (handler, name) { return _this.registerFilter(snakeCase(name), handler); });\r\n    }\r\n    Liquid.prototype.parse = function (html, filepath) {\r\n        return this.parser.parse(html, filepath);\r\n    };\r\n    Liquid.prototype._render = function (tpl, scope, renderOptions) {\r\n        var ctx = new Context(scope, this.options, renderOptions);\r\n        return this.renderer.renderTemplates(tpl, ctx);\r\n    };\r\n    Liquid.prototype.render = function (tpl, scope, renderOptions) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                return [2 /*return*/, toPromise(this._render(tpl, scope, __assign(__assign({}, renderOptions), { sync: false })))];\r\n            });\r\n        });\r\n    };\r\n    Liquid.prototype.renderSync = function (tpl, scope, renderOptions) {\r\n        return toValue(this._render(tpl, scope, __assign(__assign({}, renderOptions), { sync: true })));\r\n    };\r\n    Liquid.prototype.renderToNodeStream = function (tpl, scope, renderOptions) {\r\n        if (renderOptions === void 0) { renderOptions = {}; }\r\n        var ctx = new Context(scope, this.options, renderOptions);\r\n        return this.renderer.renderTemplatesToNodeStream(tpl, ctx);\r\n    };\r\n    Liquid.prototype._parseAndRender = function (html, scope, renderOptions) {\r\n        var tpl = this.parse(html);\r\n        return this._render(tpl, scope, renderOptions);\r\n    };\r\n    Liquid.prototype.parseAndRender = function (html, scope, renderOptions) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                return [2 /*return*/, toPromise(this._parseAndRender(html, scope, __assign(__assign({}, renderOptions), { sync: false })))];\r\n            });\r\n        });\r\n    };\r\n    Liquid.prototype.parseAndRenderSync = function (html, scope, renderOptions) {\r\n        return toValue(this._parseAndRender(html, scope, __assign(__assign({}, renderOptions), { sync: true })));\r\n    };\r\n    Liquid.prototype._parsePartialFile = function (file, sync, currentFile) {\r\n        return this.parser.parseFile(file, sync, LookupType.Partials, currentFile);\r\n    };\r\n    Liquid.prototype._parseLayoutFile = function (file, sync, currentFile) {\r\n        return this.parser.parseFile(file, sync, LookupType.Layouts, currentFile);\r\n    };\r\n    Liquid.prototype.parseFile = function (file) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                return [2 /*return*/, toPromise(this.parser.parseFile(file, false))];\r\n            });\r\n        });\r\n    };\r\n    Liquid.prototype.parseFileSync = function (file) {\r\n        return toValue(this.parser.parseFile(file, true));\r\n    };\r\n    Liquid.prototype.renderFile = function (file, ctx, renderOptions) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var templates;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.parseFile(file)];\r\n                    case 1:\r\n                        templates = _a.sent();\r\n                        return [2 /*return*/, this.render(templates, ctx, renderOptions)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Liquid.prototype.renderFileSync = function (file, ctx, renderOptions) {\r\n        var templates = this.parseFileSync(file);\r\n        return this.renderSync(templates, ctx, renderOptions);\r\n    };\r\n    Liquid.prototype.renderFileToNodeStream = function (file, scope, renderOptions) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var templates;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.parseFile(file)];\r\n                    case 1:\r\n                        templates = _a.sent();\r\n                        return [2 /*return*/, this.renderToNodeStream(templates, scope, renderOptions)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Liquid.prototype._evalValue = function (str, ctx) {\r\n        var value = new Value(str, this);\r\n        return value.value(ctx, false);\r\n    };\r\n    Liquid.prototype.evalValue = function (str, ctx) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                return [2 /*return*/, toPromise(this._evalValue(str, ctx))];\r\n            });\r\n        });\r\n    };\r\n    Liquid.prototype.evalValueSync = function (str, ctx) {\r\n        return toValue(this._evalValue(str, ctx));\r\n    };\r\n    Liquid.prototype.registerFilter = function (name, filter) {\r\n        this.filters.set(name, filter);\r\n    };\r\n    Liquid.prototype.registerTag = function (name, tag) {\r\n        this.tags.set(name, tag);\r\n    };\r\n    Liquid.prototype.plugin = function (plugin) {\r\n        return plugin.call(this, Liquid);\r\n    };\r\n    Liquid.prototype.express = function () {\r\n        var self = this; // eslint-disable-line\r\n        var firstCall = true;\r\n        return function (filePath, ctx, callback) {\r\n            var _a, _b, _c;\r\n            if (firstCall) {\r\n                firstCall = false;\r\n                var dirs = normalizeDirectoryList(this.root);\r\n                (_a = self.options.root).unshift.apply(_a, __spreadArray([], __read(dirs), false));\r\n                (_b = self.options.layouts).unshift.apply(_b, __spreadArray([], __read(dirs), false));\r\n                (_c = self.options.partials).unshift.apply(_c, __spreadArray([], __read(dirs), false));\r\n            }\r\n            self.renderFile(filePath, ctx).then(function (html) { return callback(null, html); }, callback);\r\n        };\r\n    };\r\n    return Liquid;\r\n}());\n\n\n\n\n//# sourceURL=webpack://node-starter/./node_modules/liquidjs/dist/liquid.browser.esm.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var liquidjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! liquidjs */ \"./node_modules/liquidjs/dist/liquid.browser.esm.js\");\n\n\nconst engine = new liquidjs__WEBPACK_IMPORTED_MODULE_0__.Liquid({\n  root: 'views/', // root for layouts/includes lookup\n  extname: '.liquid', // used for layouts/includes, defaults \"\"\n});\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const container = document.querySelector('div');\n  engine\n    .renderFile('test', { name: 'alicee' }) // will read and render `views/hello.liquid`\n    .then((res) => (container.innerHTML = res)); // outputs \"Alice\"\n});\n\n\n//# sourceURL=webpack://node-starter/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;